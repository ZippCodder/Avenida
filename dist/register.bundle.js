/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/register.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/register.css ***!
  \********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../public/images/photos/students.png */ \"./public/images/photos/students.png\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../../public/images/graphics/centro-pattern-transparent.png */ \"./public/images/graphics/centro-pattern-transparent.png\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n.register {\n width: 100%; \n min-height: 50vh;\n display: block; \n margin-top: 7em;\n box-sizing: border-box;\n}\n\n@keyframes fade-in {\n from {\n  opacity: 0; \n }\n to {\n  opacity: 1;\n }\n} \n\n.register__form {\n width: -moz-max-content;\n width: max-content; \n height: content; \n display: block; \n margin: auto; \n padding: 2em;\n padding-left: 5%; \n padding-right: 5%;\n overflow: hidden;\n background: white; \n border-radius: 2em;\n animation: fade-in 0.5s ease-in;\n box-shadow: 0px 0px 2px var(--blue-1);\n\n  & legend {\n   color: var(--blue-1);\n   margin-bottom: 1em; \n  }\n\n  & button[type=\"submit\"] {\n   display: block;\n   margin: auto; \n   padding: 1em;  \n   background-color: var(--blue-1);\n   border: none; \n   padding: 1em;\n   padding-left: 2em; \n   padding-right: 2em;\n   color: white; \n   font-family: var(--main-font);\n   border-radius: 1em;\n   margin-top: 1em; \n   transition: background-color 0.3s ease; \n  }\n\n  & button[type=\"submit\"]:hover {\n   background-color: var(--dark-blue);\n  }\n}\n\n.register__input {\n border: none;\n width: auto;\n box-sizing: border-box;\n margin-bottom: 1em; \n margin-left: 1em; \n box-shadow: 0px 0px 2px gray;\n border-radius: 1em;\n font-size: var(--main-font);\n padding: 1em;\n font-size: 0.8em;\n font-family: var(--main-font);\n display: inline-block;\n grid-row-start: 2;\n background: white; \n\n  & input { \n   border: none; \n   font-family: var(--main-font);\n   outline: none; \n   background: white; \n  }\n\n  & i {\n   font-size: 1.3em;\n   opacity: 0.4;\n   vertical-align: middle; \n  }\n}\n\n.register__input[name=\"email\"] {\n display: block;\n width: calc(100% - 1em); \n  \n  & input {\n   width: calc(100% - 1.6em);\n  }\n}\n\n.register__feildset {\n  display: grid;\n  grid-template-columns: 1fr 1fr; \n  grid-template-rows: auto auto; \n  width: 100%;\n  white-space: nowrap; \n}\n\n.register__heading {\n color: var(--blue-1);\n font-size: 2.5em;\n margin-top: 0;\n text-align: center; \n}\n\n.register__image {\n background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n width: 100%; \n height: 100%;\n background-color: red; \n border-radius: 2em;\n border-top-left-radius: 0px; \n border-bottom-left-radius: 0px; \n background-size: cover;\n background-position: center center; \n background-repeat: no-repeat;\n filter: brightness(60%);\n}\n\n.register__tos {\n color: var(--dark-gray);\n font-size: 0.8em;\n text-align: center; \n\n  & input {\n    background-color: var(--blue-1);\n    width: 1.5em; \n    height: 1.5em;\n    vertical-align: middle; \n    margin-right: 1em;\n  }\n}\n\n.register__password-details {\n width: 100%;\n display: block; \n margin: auto; \n border-radius: 1em;\n background-color: var(--blue-3);\n color: var(--blue-1);\n padding-top: 0.5em; \n padding-bottom: 0.5em;\n margin-bottom: 1em;\n font-size: 0.8em; \n}\n\n.register__success {\n width: -moz-max-content;\n width: max-content; \n padding: 2em; \n background: white; \n border-radius: 2em;\n text-align: center; \n display: block; \n margin: auto; \n padding-top: 8em; \n background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});\n background-size: contain;\n background-position: center top;\n background-repeat: no-repeat;\n box-sizing: border-box; \n\n  & i {\n   font-size: 4em; \n   color: var(--green-1);\n  }\n}\n\n.register__success-heading {\n font-size: 2em;\n margin-bottom: 0.5em;\n}\n\n.register__success-message {\n color: var(--dark-gray);\n font-size: 0.8em; \n}\n\n@media all and (max-width: 580px) {\n .register__input {\n  display: block; \n  width: calc(100% - 1em); \n\n  & input {\n   width: calc(100% - 1.6em);\n  }\n }\n\n .register__feildset {\n  display: block; \n }\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/styles/register.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css ***!
  \******************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\nhtml, body {\nwidth: 100%; \nheight: 100%; \npadding: 0; \nmargin: 0; \nbox-sizing: border-box;\nfont-family: var(--main-font);\nbackground-color: var(--blue-4);\n}\n\n:root {\n--dark-gray: #2b2b2b; \n--blue-1: #5479f7;\n--blue-2: #99b9ff;\n--blue-3: #caddff;\n--blue-4: #ebf2ff;\n--light-gray: #BBBBBB;\n--dark-blue: #1e4ef4;\n--dark-gray: #444444;\n--orange-1: #ffb0a0;\n--orange-2: #fed7cf;\n--green-1: #73d957;\n--green-2: #b9ebab;\n--main-font: \"Outfit\", sans-serif;\n--scroll: 0;\n}\n\n.main-container {\n width: 100%;\n height: 100%;\n padding-left: 2em; \n padding-right: 2em;\n box-sizing: border-box;\n overflow-x: hidden; \n}\n\n@media all and (max-width: 700px) {\n .main-container {\n  font-size: calc(0.5em + 1vw);\n }\n\n @media all and (max-width: 400px) {\n  .main-container {\n   padding: 0; \n  }\n }\n}\n\nfooter {\n display: flex;\n flex-direction: column;\n justify-content: center; \n position: relative;\n width: calc(100% + 5em); \n height: content;\n margin-top: 10%;  \n background: rgba(255, 255, 255, 0.8);\n z-index: 3;\n left: -2.5em;\n padding-top: 4em;\n padding-bottom: 1em;\n box-sizing: border-box;\n font-size: 0.8em;\n\n  .footer__content {\n   display: flex;\n   justify-content: space-around; \n   width: 100%;\n   padding-left: 10%; \n   padding-right: 10%; \n   box-sizing: border-box; \n  }\n\n  .footer__copyright {\n   display: block;\n   width: 100%;\n   padding: 0;\n   color: var(--dark-gray);\n   padding: 1em;\n   text-align: center;\n   margin-top: 4em; \n  }\n\n  .footer__title {\n   display: inline-block; \n   position: relative; \n   width: -moz-min-content; \n   width: min-content; \n   height: content;\n   text-align: center;\n   vertical-align: top;\n\n   & p {\n    font-size: 0.7em;\n    letter-spacing: 0.6em; \n    font-weight: 400; \n   }\n\n   & img {\n    height: 3em;\n    display: block; \n    left: 0;\n   }\n  }\n\n   .footer__menu {\n    width: content; \n    color: var(--blue-1);\n    display: inline-block;\n    text-align: left;\n    vertical-align: top;\n\n   & h3 {\n    width: 100%;\n    font-size: 2em;\n    margin: 0;\n    margin-bottom: 0.5em;\n    color: black; \n   }\n\n   & nav {\n    width: -moz-max-content;\n    width: max-content; \n   }\n\n    & a, p {\n     text-decoration: none;\n     color: var(--dark-gray);\n     margin-bottom: 1em;\n     display: block; \n    }\n  }\n}\n\n@media all and (max-width: 1150px) {\n .footer__content {\n  flex-direction: column; \n }\n\n  .footer__title {\n   margin-bottom: 3em !important;\n  }\n\n  @media (min-width: 900px) {\n  .footer__menu {\n    & a, p {\n     display: inline-block !important;\n     margin-right: 2em; \n    }\n   }\n  }\n}\n\n.header {\n position: fixed; \n display: flex;\n z-index: 4; \n background: rgba(255, 255, 255, 0.9);\n align-items: center;\n justify-content: space-between;\n flex-direction: row; \n top: 0; \n width: calc(100%); \n height: 5em;\n box-sizing: border-box;\n -webkit-user-select: none;\n    -moz-user-select: none;\n         user-select: none;\n padding-left: 2em;\n padding-right: 2em;\n left: 0; \n}\n\n@media all and (max-width: 950px) {\n  .nav__link:nth-child(1) {\n    display: none; \n  }\n}\n\n@media all and (max-width: 820px) {\n  .header__nav {\n    display: none; \n  }\n}\n\n.header__logo {\n height: 50%;\n vertical-align: middle;\n -webkit-user-select: none;\n    -moz-user-select: none;\n         user-select: none; \n}\n\n.header__subtitle {\n font-family: var(--main-font);\n letter-spacing: 0.6em;\n font-size: 0.6em;\n font-weight: 400;\n}\n\n.dropdown__dot {\n width: 0.5em; \n height: 0.5em; \n background: black;\n border-radius: 0.2em;\n margin: 0.2em; \n}\n\n.nav__link {\ncolor: var(--dark-gray); \nfont-family: var(--main-font);\ntext-decoration: none;\nmargin-left: 4em; \nfont-size: 1em;\ntransition: color 0.2s ease;\nfont-weight: 300;\n}\n\n.nav__link:hover {\ncolor: var(--blue-1);\n}\n\n.header__submenu {\n display: block; \n position: absolute;\n width: -moz-max-content;\n width: max-content; \n height: -moz-max-content; \n height: max-content;\n transform: translate(-100%, 0);\n background-color: white;\n padding: 1em;\n border-radius: 1em; \n box-shadow: 0px 0px 2px var(--blue-1);\n}\n\n.header__sublink {\n display: block; \n margin-bottom: 1em; \n text-decoration: none; \n color: var(--blue-1);\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/styles/styles.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url[\"default\"] : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function _typeof(o){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&\"function\"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?\"symbol\":typeof o;},_typeof(o);}if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=true;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol[\"for\"]('react.element');var REACT_PORTAL_TYPE=Symbol[\"for\"]('react.portal');var REACT_FRAGMENT_TYPE=Symbol[\"for\"]('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol[\"for\"]('react.strict_mode');var REACT_PROFILER_TYPE=Symbol[\"for\"]('react.profiler');var REACT_PROVIDER_TYPE=Symbol[\"for\"]('react.provider');var REACT_CONTEXT_TYPE=Symbol[\"for\"]('react.context');var REACT_FORWARD_REF_TYPE=Symbol[\"for\"]('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol[\"for\"]('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol[\"for\"]('react.suspense_list');var REACT_MEMO_TYPE=Symbol[\"for\"]('react.memo');var REACT_LAZY_TYPE=Symbol[\"for\"]('react.lazy');var REACT_SCOPE_TYPE=Symbol[\"for\"]('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol[\"for\"]('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol[\"for\"]('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol[\"for\"]('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol[\"for\"]('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol[\"for\"]('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||_typeof(maybeIterable)!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function Fake(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if((typeof Reflect===\"undefined\"?\"undefined\":_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node[\"return\"];}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(_typeof(value)){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp *//**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n *//**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(_typeof(props.dangerouslySetInnerHTML)!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&_typeof(props.style)!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',\"class\":'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',\"default\":'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',\"for\":'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',\"in\":'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',\"typeof\":'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function flushSyncImpl(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+_typeof(listener)+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&_typeof(error)==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node[\"return\"];}nextNode=node[\"return\"];}while(nextNode);}else{while(node[\"return\"]){node=node[\"return\"];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a[\"return\"];if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA[\"return\"];if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a[\"return\"]!==b[\"return\"]){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers[\"delete\"](pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures[\"delete\"](_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map[\"delete\"](key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function persist(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */// Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(_typeof(detail)==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent[\"char\"]&&nativeEvent[\"char\"].length>1){return nativeEvent[\"char\"];}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(_typeof(objA)!=='object'||objA===null||_typeof(objB)!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n *//**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node[\"return\"];while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode[\"return\"];}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node[\"return\"];}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance[\"return\"];}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance[\"return\"];}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst[\"return\"];// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance[\"return\"];}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback)[\"catch\"](handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node[\"return\"];}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId — it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress[\"return\"];if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete[\"return\"]=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment[\"return\"]=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber[\"return\"];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent[\"return\"];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node[\"return\"];}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||_typeof(child)!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(_typeof(child._store)!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function isReactClass(type){return type.prototype&&type.prototype.isReactComponent;}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&_typeof(mixedRef)!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)&&// Will already throw with \"Function components cannot have string refs\"\n!(element._owner&&element._owner.tag!==ClassComponent)&&// Will already warn with \"Function components cannot be given refs\"\n!(typeof element.type==='function'&&!isReactClass(element.type))&&// Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\nelement._owner){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('Component \"%s\" contains the string ref \"%s\". Support for string refs '+'will be removed in a future major release. We recommend using '+'useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',componentName,mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=resolvedInst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing[\"return\"]=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created[\"return\"]=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing[\"return\"]=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created[\"return\"]=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2[\"return\"]=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3[\"return\"]=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(_typeof(child)!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing[\"return\"]=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing[\"return\"]=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created[\"return\"]=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4[\"return\"]=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=_typeof(newChild)==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild[\"return\"]=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild[\"return\"]=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node[\"return\"];}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber[\"return\"]=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber[\"return\"];if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber[\"return\"]=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling[\"return\"]=nextFiber[\"return\"];nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber[\"return\"];}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function _readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber[\"return\"];while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent[\"return\"];}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===row){return null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function handleStoreChange(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber[\"return\"];}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber[\"return\"];}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var fakeInternalInstance={};var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;var didWarnAboutLegacyContext$1;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();didWarnAboutLegacyContext$1=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(ctor.childContextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy childContextTypes API which is no longer '+'supported and will be removed in the next major release. Use '+'React.createContext() instead\\n\\n.'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(ctor.contextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy contextTypes API which is no longer supported '+'and will be removed in the next major release. Use '+'React.createContext() with static contextType instead.\\n\\n'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(_typeof(_state)!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(_typeof(contextType)!=='object'){addendum=' However, it is set to a '+_typeof(contextType)+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(_typeof(contextType)==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs={};initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(_typeof(contextType)==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node[\"return\"];}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&_typeof(value)==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress[\"return\"];}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;var didWarnAboutDefaultPropsOnFunctionComponent;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};didWarnAboutDefaultPropsOnFunctionComponent={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(type)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from memo components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child[\"return\"]=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild[\"return\"]=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway — like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&_typeof(Component)==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\n_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from function components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment[\"return\"]=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required — every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress[\"return\"];if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress[\"return\"]=oldWorkInProgress[\"return\"];newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}};updateHostContainer=function updateHostContainer(current,workInProgress){// Noop\n};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child[\"return\"]=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3[\"return\"]=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber[\"return\"];}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber[\"return\"];}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node[\"return\"],instance);}safelyAttachRef(node,node[\"return\"]);break;}case HostComponent:{safelyAttachRef(node,node[\"return\"]);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node[\"return\"];}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate[\"return\"]=null;}fiber[\"return\"]=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical — it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber[\"return\"]=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber[\"return\"];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent[\"return\"];}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node[\"return\"]===null||isHostParent(node[\"return\"])){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child[\"return\"]=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent[\"return\"];}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork[\"return\"]);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber[\"return\"]);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber[\"return\"]);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild[\"return\"]=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber[\"return\"];{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling[\"return\"]=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol[\"for\"]){var symbolFor=Symbol[\"for\"];COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\" — a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child[\"return\"]=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return true;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress[\"return\"];while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork[\"return\"];}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork[\"return\"]===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&_typeof(thrownValue)==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork[\"return\"],erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork[\"return\"];workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork[\"return\"];// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed — that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber[\"return\"];}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache[\"delete\"](wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache[\"delete\"](wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current[\"return\"];}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&_typeof(originalError)==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(_typeof(replayError)==='object'&&replayError!==null&&replayError._suppressLogging&&_typeof(originalError)==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=_typeof(nextType)==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node[\"return\"]===null){throw new Error('Expected to reach root first.');}node=node[\"return\"];}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===fiber){return foundHostInstances;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis[\"return\"]=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point–\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(_typeof(type)==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||_typeof(type)==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:_typeof(type))+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',_typeof(pendingProps.id));}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target[\"return\"]=source[\"return\"];target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.3.1';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function shouldErrorImpl(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var _copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=_copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return _copyWithDeleteImpl(obj,path,0);};var _copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=_copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return _copyWithRenameImpl(obj,oldPath,newPath,0);};var _copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=_copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return _copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function scheduleUpdate(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function setErrorHandler(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(_typeof(options)==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}var didWarnAboutFindDOMNode=false;function findDOMNode(componentOrElement){{if(!didWarnAboutFindDOMNode){didWarnAboutFindDOMNode=true;error('findDOMNode is deprecated and will be removed in the next major '+'release. Instead, add a ref directly to the element you want '+'to reference. Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node');}var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}var didWarnAboutUnmountComponentAtNode=false;function unmountComponentAtNode(container){{if(!didWarnAboutUnmountComponentAtNode){didWarnAboutUnmountComponentAtNode=true;error('unmountComponentAtNode is deprecated and will be removed in the '+'next major release. Switch to the createRoot API. Learn '+'more: https://reactjs.org/link/switch-to-createroot');}}if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}\n\n//# sourceURL=webpack:///./node_modules/react-dom/cjs/react-dom.development.js?");

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function (c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function (c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/react-dom/client.js?");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/react-dom/index.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.3.1';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol[\"for\"]('react.element');\n    var REACT_PORTAL_TYPE = Symbol[\"for\"]('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol[\"for\"]('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol[\"for\"]('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol[\"for\"]('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol[\"for\"]('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol[\"for\"]('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol[\"for\"]('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol[\"for\"]('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"]('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol[\"for\"]('react.memo');\n    var REACT_LAZY_TYPE = Symbol[\"for\"]('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol[\"for\"]('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function isMounted(publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (_typeof(partialState) !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function get() {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function warnAboutAccessingKey() {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function warnAboutAccessingRef() {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (_typeof(element) === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = _typeof(children);\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function get() {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function set(_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function get() {\n              return context._currentValue;\n            },\n            set: function set(_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function get() {\n              return context._currentValue2;\n            },\n            set: function set(_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function get() {\n              return context._threadCount;\n            },\n            set: function set(_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function get() {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function get() {\n              return context.displayName;\n            },\n            set: function set(displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject[\"default\"];\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function get() {\n              return defaultProps;\n            },\n            set: function set(newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function get() {\n              return propTypes;\n            },\n            set: function set(newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : _typeof(render));\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol[\"for\"]('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (_typeof(type) === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : _typeof(type));\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (_typeof(node) !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = _typeof(type);\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function get() {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function enqueueTaskImpl(callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && _typeof(result) === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function then(resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function then(resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function then(resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.act = act;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack:///./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (_typeof(options) === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function performWorkUntilDeadline() {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack:///./node_modules/scheduler/cjs/scheduler.development.js?");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/scheduler/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./public/images/graphics/centro-pattern-transparent.png":
/*!***************************************************************!*\
  !*** ./public/images/graphics/centro-pattern-transparent.png ***!
  \***************************************************************/
/***/ ((module) => {

eval("module.exports = \"data:image/png;base64,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\";\n\n//# sourceURL=webpack:///./public/images/graphics/centro-pattern-transparent.png?");

/***/ }),

/***/ "./public/images/photos/students.png":
/*!*******************************************!*\
  !*** ./public/images/photos/students.png ***!
  \*******************************************/
/***/ ((module) => {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAGqCAYAAACbEvXuAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEzWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI1LTA2LTI0PC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjQ0MTc4NjhhLWRlZTMtNDAxOC05MTJlLTEyM2ZkMTEzMmViODwvQXR0cmliOkV4dElkPgogICAgIDxBdHRyaWI6RmJJZD41MjUyNjU5MTQxNzk1ODA8L0F0dHJpYjpGYklkPgogICAgIDxBdHRyaWI6VG91Y2hUeXBlPjI8L0F0dHJpYjpUb3VjaFR5cGU+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6U2VxPgogIDwvQXR0cmliOkFkcz4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6ZGM9J2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJz4KICA8ZGM6dGl0bGU+CiAgIDxyZGY6QWx0PgogICAgPHJkZjpsaSB4bWw6bGFuZz0neC1kZWZhdWx0Jz5zdHVkZW50cyAtIDE8L3JkZjpsaT4KICAgPC9yZGY6QWx0PgogIDwvZGM6dGl0bGU+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjph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\";\n\n//# sourceURL=webpack:///./public/images/photos/students.png?");

/***/ }),

/***/ "./public/styles/register.css":
/*!************************************!*\
  !*** ./public/styles/register.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_register_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./register.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/register.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_register_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_register_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_register_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_register_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./public/styles/register.css?");

/***/ }),

/***/ "./public/styles/styles.css":
/*!**********************************!*\
  !*** ./public/styles/styles.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./public/styles/styles.css?");

/***/ }),

/***/ "./src/components/footer.jsx":
/*!***********************************!*\
  !*** ./src/components/footer.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Footer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer(props) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"footer\", {\n    className: \"footer\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__content\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__title\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"footer__logo\",\n    src: \"/public/images/icons/centro-website-logo.png\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"JOB SERVICES\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Pages\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"My Account\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Our Services\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Applicant Profile Review\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Resume and Cover Letter Optimization\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Job Application Tailoring\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Virtual Job Application\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"More\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Terms and Conditions\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Privacy Policy\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"Cookie Policy\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Contact\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"admin@crcentro.com\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"(+506) 7063-8994\")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__copyright\"\n  }, \"\\xA9 2025 Copyright Centro, All rights reserved.\"));\n}\n\n//# sourceURL=webpack:///./src/components/footer.jsx?");

/***/ }),

/***/ "./src/components/header.jsx":
/*!***********************************!*\
  !*** ./src/components/header.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Header)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nfunction Header() {\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    menuOpen = _React$useState2[0],\n    setMenuOpen = _React$useState2[1];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"header\", {\n    className: \"header\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"header__logo\",\n    src: \"/public/images/icons/centro-website-logo.png\",\n    onClick: function onClick() {\n      return window.location = \"/\";\n    }\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h2\", {\n    className: \"header__subtitle\"\n  }, \"JOB SERVICES\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", {\n    className: \"header__nav\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/pricing\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/register\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/register\"\n  }, \"My Account\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"header__dropdown\",\n    onClick: function onClick() {\n      return setMenuOpen(!menuOpen);\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", {\n    className: \"header__submenu\",\n    style: {\n      display: menuOpen ? \"block\" : \"none\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/pricing\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/register\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/register\"\n  }, \"Login\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/register\"\n  }, \"My Account\")))));\n}\n\n//# sourceURL=webpack:///./src/components/header.jsx?");

/***/ }),

/***/ "./src/register.jsx":
/*!**************************!*\
  !*** ./src/register.jsx ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n/* harmony import */ var _components_header_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/header.jsx */ \"./src/components/header.jsx\");\n/* harmony import */ var _components_footer_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/footer.jsx */ \"./src/components/footer.jsx\");\n/* harmony import */ var _public_styles_styles_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../public/styles/styles.css */ \"./public/styles/styles.css\");\n/* harmony import */ var _public_styles_register_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/styles/register.css */ \"./public/styles/register.css\");\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\n\nfunction Feild(props) {\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    filled = _React$useState2[0],\n    setFilled = _React$useState2[1];\n  var input = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  function change() {\n    if (input.current.value !== \"\") {\n      setFilled(true);\n      return;\n    }\n    setFilled(false);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__input\",\n    name: props.name\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    type: props.password ? \"password\" : \"text\",\n    ref: input,\n    name: props.name,\n    onChange: change,\n    placeholder: props.placeholder,\n    minlength: props.minlength,\n    required: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-circle-check\",\n    style: {\n      color: filled ? \"var(--green-1)\" : \"black\",\n      opacity: filled ? \"1\" : \"0.4\"\n    }\n  }));\n}\nfunction App() {\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    submitted = _React$useState4[0],\n    setSubmitted = _React$useState4[1];\n  var form = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  function submit(e) {\n    e.preventDefault();\n    setSubmitted(null);\n    var _form$current$element = form.current.elements,\n      firstname = _form$current$element.firstname,\n      lastname = _form$current$element.lastname,\n      email = _form$current$element.email,\n      password = _form$current$element.password,\n      password_re = _form$current$element.password_re,\n      tos = _form$current$element.tos;\n    fetch(\"/register\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        firstname: firstname.value,\n        lastname: lastname.value,\n        email: email.value,\n        password: password.value,\n        passwordre: password_re.value,\n        tos: tos.value\n      })\n    }).then(function (data) {\n      setSubmitted(true);\n    });\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"main-container\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_header_jsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"main\", {\n    className: \"register\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__success\",\n    style: {\n      display: submitted ? \"block\" : \"none\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-circle-check\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n    className: \"register__success-heading\"\n  }, \"Success!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", {\n    className: \"register__success-message\"\n  }, \"You'll receive an email link shortly for you to fill out your applicant profile.\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"form\", {\n    ref: form,\n    onSubmit: submit,\n    className: \"register__form\",\n    method: \"POST\",\n    action: \"/register\",\n    style: {\n      display: submitted ? \"none\" : \"block\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h1\", {\n    className: \"register__heading\"\n  }, \"Create your account!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"feildset\", {\n    className: \"register__feildset\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"legend\", null, \"Your Info:\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    name: \"firstname\",\n    placeholder: \"First Name\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    name: \"lastname\",\n    placeholder: \"Last Name\"\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    name: \"email\",\n    placeholder: \"Email\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"feildset\", {\n    className: \"register__feildset\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"legend\", null, \"Your Password:\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    password: true,\n    minlength: 8,\n    name: \"password\",\n    placeholder: \"Password\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    password: true,\n    minlength: 8,\n    name: \"password_re\",\n    placeholder: \"Confirm Password\"\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__password-details\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", null, \"Password length must be at least 8 characters\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", null, \"Must contain at least 1 special character\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", null, \"Must not be the same as your email\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", null, \"Passwords must match\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__tos\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    type: \"checkbox\",\n    name: \"tos\",\n    required: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", {\n    htmlFor: \"tos\"\n  }, \"I agree to the Terms of Service and Privacy Policy.\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    type: \"submit\",\n    style: {\n      opacity: submitted === null ? \"0.5\" : \"1\"\n    }\n  }, \"Submit\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_footer_jsx__WEBPACK_IMPORTED_MODULE_3__[\"default\"], null)));\n}\nvar root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(document.getElementById(\"root\"));\nroot.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, null));\n\n//# sourceURL=webpack:///./src/register.jsx?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"register": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/register.jsx");
/******/ 	
/******/ })()
;