/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/checkout.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/checkout.css ***!
  \********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ``, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/styles/checkout.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/reviews.css":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/reviews.css ***!
  \*******************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\nfooter {\n margin-top: 0 !important; \n}\n\n.reviews {\n width: calc(100% + 4em);\n display: block;\n justify-content: center; \n margin: auto; \n margin-top: 5em; \n background: rgba(255, 255, 255, 0.8);\n padding-bottom: 5em;\n text-align: center; \n transform: translateX(-2em);\n padding-top: 4em; \n\n & .reviews__heading {\n  display: block; \n  font-size: 2em;\n  margin: auto; \n  margin-top: 0;\n  margin-bottom: 2.5em;\n  width: 80%; \n }\n}\n\n.review {\n width: -moz-max-content;\n width: max-content;\n height: content;\n display: inline-block; \n background: white;\n padding-top: 1em; \n padding-bottom: 2em; \n border-radius: 2em;\n font-size: 0.8em;\n text-align: center;\n box-shadow: 0px 0px 5px gray;\n margin-left: 1em; \n margin-right: 1em;\n\n & .review__quote {\n  color: var(--dark-gray);\n  display: block;\n  margin-top: 1em;\n  padding-top: 1em; \n  width: 100%;\n  border-top: 1px solid var(--blue-2);\n  padding-left: 2em; \n  padding-right: 2em;\n  box-sizing: border-box;\n  width: 25em;\n }\n\n & .review__stars {\n  color: var(--blue-1);\n  font-size: 1.5em; \n  display: block; \n  margin: auto; \n  margin-top: 1em;\n  background: var(--blue-3);\n  width: -moz-max-content;\n  width: max-content; \n  padding: 1em;\n  border-radius: 1em; \n\n  & p {\n   display: inline-block;\n   margin: 0; \n   margin-left: 1em;\n  }\n }\n\n & .review__name {\n  display: inline-block; \n  vertical-align: middle; \n }\n\n & .review__profile {\n  display: inline-block;\n  vertical-align: middle; \n  width: 3em; \n  height: 3em; \n  border-radius: 0.5em; \n  margin-left: 2em; \n }\n}\n\n@media all and (max-width: 1039px) {\n .review {\n  margin-bottom: 2em; \n }\n} \n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/styles/reviews.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css ***!
  \******************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../../../public/fonts/Outfit/Outfit-VariableFont_wght.ttf */ \"./public/fonts/Outfit/Outfit-VariableFont_wght.ttf\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n@font-face {\n font-family: \"Outfit\";\n src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format(\"truetype\");\n font-style: normal; \n font-weight: 100 900;\n}\n\nhtml, body {\nwidth: 100%; \nheight: 100%; \npadding: 0; \nmargin: 0; \nbox-sizing: border-box;\nfont-family: var(--main-font);\nbackground-color: var(--blue-4);\n}\n\n:root {\n--dark-gray: #2b2b2b; \n--blue-1: #5479f7;\n--blue-2: #99b9ff;\n--blue-3: #caddff;\n--blue-4: #ebf2ff;\n--light-gray: #BBBBBB;\n--dark-blue: #1e4ef4;\n--dark-gray: #444444;\n--orange-1: #ffb0a0;\n--orange-2: #fed7cf;\n--green-1: #73d957;\n--green-2: #b9ebab;\n--main-font: \"Outfit\", sans-serif;\n--scroll: 0;\n}\n\n.main-container {\n width: 100%;\n height: 100%;\n padding-left: 2em; \n padding-right: 2em;\n box-sizing: border-box;\n overflow-x: hidden; \n}\n\n@media all and (max-width: 700px) {\n .main-container {\n  font-size: calc(0.5em + 1vw);\n }\n\n @media all and (max-width: 400px) {\n  .main-container {\n   padding: 0; \n  }\n }\n}\n\nfooter {\n display: flex;\n flex-direction: column;\n justify-content: center; \n position: relative;\n width: calc(100% + 5em); \n height: content;\n margin-top: 10%;  \n background: rgba(255, 255, 255, 0.8);\n z-index: 3;\n left: -2.5em;\n padding-top: 4em;\n padding-bottom: 1em;\n box-sizing: border-box;\n font-size: 0.8em;\n\n  .footer__content {\n   display: flex;\n   justify-content: space-around; \n   width: 100%;\n   padding-left: 10%; \n   padding-right: 10%; \n   box-sizing: border-box; \n  }\n\n  .footer__copyright {\n   display: block;\n   width: 100%;\n   padding: 0;\n   color: var(--dark-gray);\n   padding: 1em;\n   text-align: center;\n   margin-top: 4em; \n  }\n\n  .footer__title {\n   display: inline-block; \n   position: relative; \n   width: -moz-min-content; \n   width: min-content; \n   height: content;\n   text-align: center;\n   vertical-align: top;\n\n   & p {\n    font-size: 0.7em;\n    letter-spacing: 0.6em; \n    font-weight: 400; \n   }\n\n   & img {\n    height: 3em;\n    display: block; \n    left: 0;\n   }\n  }\n\n   .footer__menu {\n    width: content; \n    color: var(--blue-1);\n    display: inline-block;\n    text-align: left;\n    vertical-align: top;\n\n   & h3 {\n    width: 100%;\n    font-size: 2em;\n    margin: 0;\n    margin-bottom: 0.5em;\n    color: black; \n   }\n\n   & nav {\n    width: -moz-max-content;\n    width: max-content; \n   }\n\n    & a, p {\n     text-decoration: none;\n     color: var(--dark-gray);\n     margin-bottom: 1em;\n     display: block; \n    }\n  }\n}\n\n@media all and (max-width: 1150px) {\n .footer__content {\n  flex-direction: column; \n }\n\n  .footer__title {\n   margin-bottom: 3em !important;\n  }\n\n  @media (min-width: 900px) {\n  .footer__menu {\n    & a, p {\n     display: inline-block !important;\n     margin-right: 2em; \n    }\n   }\n  }\n}\n\n.header {\n position: fixed; \n display: flex;\n z-index: 4; \n background: rgba(255, 255, 255, 0.9);\n align-items: center;\n justify-content: space-between;\n flex-direction: row; \n top: 0; \n width: calc(100%); \n height: 5em;\n box-sizing: border-box;\n -webkit-user-select: none;\n    -moz-user-select: none;\n         user-select: none;\n padding-left: 2em;\n padding-right: 2em;\n left: 0; \n}\n\n@media all and (max-width: 950px) {\n  .nav__link:nth-child(1) {\n    display: none; \n  }\n}\n\n@media all and (max-width: 820px) {\n  .header__nav {\n    display: none; \n  }\n}\n\n.header__logo {\n height: 50%;\n vertical-align: middle;\n -webkit-user-select: none;\n    -moz-user-select: none;\n         user-select: none; \n}\n\n.header__subtitle {\n font-family: var(--main-font);\n letter-spacing: 0.6em;\n font-size: 0.6em;\n font-weight: 400;\n}\n\n.dropdown__dot {\n width: 0.5em; \n height: 0.5em; \n background: black;\n border-radius: 0.2em;\n margin: 0.2em; \n}\n\n.nav__link {\ncolor: var(--dark-gray); \nfont-family: var(--main-font);\ntext-decoration: none;\nmargin-left: 4em; \nfont-size: 1em;\ntransition: color 0.2s ease;\nfont-weight: 300;\n}\n\n.nav__link:hover {\ncolor: var(--blue-1);\n}\n\n.header__submenu {\n display: block; \n position: absolute;\n width: -moz-max-content;\n width: max-content; \n height: -moz-max-content; \n height: max-content;\n transform: translate(-100%, 0);\n background-color: white;\n padding: 1em;\n border-radius: 1em; \n box-shadow: 0px 0px 2px var(--blue-1);\n}\n\n.header__sublink {\n display: block; \n margin-bottom: 1em; \n text-decoration: none; \n color: var(--blue-1);\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/styles/styles.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url[\"default\"] : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function _typeof(o){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&\"function\"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?\"symbol\":typeof o;},_typeof(o);}if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=true;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol[\"for\"]('react.element');var REACT_PORTAL_TYPE=Symbol[\"for\"]('react.portal');var REACT_FRAGMENT_TYPE=Symbol[\"for\"]('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol[\"for\"]('react.strict_mode');var REACT_PROFILER_TYPE=Symbol[\"for\"]('react.profiler');var REACT_PROVIDER_TYPE=Symbol[\"for\"]('react.provider');var REACT_CONTEXT_TYPE=Symbol[\"for\"]('react.context');var REACT_FORWARD_REF_TYPE=Symbol[\"for\"]('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol[\"for\"]('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol[\"for\"]('react.suspense_list');var REACT_MEMO_TYPE=Symbol[\"for\"]('react.memo');var REACT_LAZY_TYPE=Symbol[\"for\"]('react.lazy');var REACT_SCOPE_TYPE=Symbol[\"for\"]('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol[\"for\"]('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol[\"for\"]('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol[\"for\"]('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol[\"for\"]('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol[\"for\"]('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||_typeof(maybeIterable)!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function Fake(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if((typeof Reflect===\"undefined\"?\"undefined\":_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node[\"return\"];}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(_typeof(value)){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp *//**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n *//**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(_typeof(props.dangerouslySetInnerHTML)!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&_typeof(props.style)!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',\"class\":'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',\"default\":'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',\"for\":'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',\"in\":'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',\"typeof\":'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function flushSyncImpl(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+_typeof(listener)+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&_typeof(error)==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node[\"return\"];}nextNode=node[\"return\"];}while(nextNode);}else{while(node[\"return\"]){node=node[\"return\"];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a[\"return\"];if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA[\"return\"];if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a[\"return\"]!==b[\"return\"]){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers[\"delete\"](pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures[\"delete\"](_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map[\"delete\"](key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function persist(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */// Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(_typeof(detail)==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent[\"char\"]&&nativeEvent[\"char\"].length>1){return nativeEvent[\"char\"];}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(_typeof(objA)!=='object'||objA===null||_typeof(objB)!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n *//**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node[\"return\"];while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode[\"return\"];}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node[\"return\"];}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance[\"return\"];}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance[\"return\"];}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst[\"return\"];// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance[\"return\"];}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback)[\"catch\"](handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node[\"return\"];}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId — it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress[\"return\"];if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete[\"return\"]=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment[\"return\"]=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber[\"return\"];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent[\"return\"];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node[\"return\"];}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||_typeof(child)!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(_typeof(child._store)!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function isReactClass(type){return type.prototype&&type.prototype.isReactComponent;}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&_typeof(mixedRef)!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)&&// Will already throw with \"Function components cannot have string refs\"\n!(element._owner&&element._owner.tag!==ClassComponent)&&// Will already warn with \"Function components cannot be given refs\"\n!(typeof element.type==='function'&&!isReactClass(element.type))&&// Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\nelement._owner){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('Component \"%s\" contains the string ref \"%s\". Support for string refs '+'will be removed in a future major release. We recommend using '+'useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',componentName,mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=resolvedInst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing[\"return\"]=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created[\"return\"]=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing[\"return\"]=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created[\"return\"]=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2[\"return\"]=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3[\"return\"]=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(_typeof(child)!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing[\"return\"]=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing[\"return\"]=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created[\"return\"]=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4[\"return\"]=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=_typeof(newChild)==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild[\"return\"]=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild[\"return\"]=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node[\"return\"];}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber[\"return\"]=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber[\"return\"];if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber[\"return\"]=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling[\"return\"]=nextFiber[\"return\"];nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber[\"return\"];}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function _readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber[\"return\"];while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent[\"return\"];}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===row){return null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function handleStoreChange(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber[\"return\"];}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber[\"return\"];}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var fakeInternalInstance={};var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;var didWarnAboutLegacyContext$1;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();didWarnAboutLegacyContext$1=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(ctor.childContextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy childContextTypes API which is no longer '+'supported and will be removed in the next major release. Use '+'React.createContext() instead\\n\\n.'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(ctor.contextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy contextTypes API which is no longer supported '+'and will be removed in the next major release. Use '+'React.createContext() with static contextType instead.\\n\\n'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(_typeof(_state)!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(_typeof(contextType)!=='object'){addendum=' However, it is set to a '+_typeof(contextType)+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(_typeof(contextType)==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs={};initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(_typeof(contextType)==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node[\"return\"];}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&_typeof(value)==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress[\"return\"];}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;var didWarnAboutDefaultPropsOnFunctionComponent;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};didWarnAboutDefaultPropsOnFunctionComponent={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(type)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from memo components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child[\"return\"]=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild[\"return\"]=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway — like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&_typeof(Component)==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\n_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from function components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment[\"return\"]=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required — every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress[\"return\"];if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress[\"return\"]=oldWorkInProgress[\"return\"];newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}};updateHostContainer=function updateHostContainer(current,workInProgress){// Noop\n};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child[\"return\"]=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3[\"return\"]=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber[\"return\"];}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber[\"return\"];}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node[\"return\"],instance);}safelyAttachRef(node,node[\"return\"]);break;}case HostComponent:{safelyAttachRef(node,node[\"return\"]);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node[\"return\"];}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate[\"return\"]=null;}fiber[\"return\"]=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical — it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber[\"return\"]=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber[\"return\"];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent[\"return\"];}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node[\"return\"]===null||isHostParent(node[\"return\"])){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child[\"return\"]=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent[\"return\"];}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork[\"return\"]);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber[\"return\"]);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber[\"return\"]);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild[\"return\"]=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber[\"return\"];{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling[\"return\"]=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol[\"for\"]){var symbolFor=Symbol[\"for\"];COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\" — a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child[\"return\"]=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return true;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress[\"return\"];while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork[\"return\"];}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork[\"return\"]===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&_typeof(thrownValue)==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork[\"return\"],erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork[\"return\"];workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork[\"return\"];// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed — that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber[\"return\"];}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache[\"delete\"](wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache[\"delete\"](wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current[\"return\"];}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&_typeof(originalError)==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(_typeof(replayError)==='object'&&replayError!==null&&replayError._suppressLogging&&_typeof(originalError)==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=_typeof(nextType)==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node[\"return\"]===null){throw new Error('Expected to reach root first.');}node=node[\"return\"];}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===fiber){return foundHostInstances;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis[\"return\"]=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point–\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(_typeof(type)==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||_typeof(type)==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:_typeof(type))+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',_typeof(pendingProps.id));}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target[\"return\"]=source[\"return\"];target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.3.1';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function shouldErrorImpl(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var _copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=_copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return _copyWithDeleteImpl(obj,path,0);};var _copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=_copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return _copyWithRenameImpl(obj,oldPath,newPath,0);};var _copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=_copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return _copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function scheduleUpdate(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function setErrorHandler(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(_typeof(options)==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}var didWarnAboutFindDOMNode=false;function findDOMNode(componentOrElement){{if(!didWarnAboutFindDOMNode){didWarnAboutFindDOMNode=true;error('findDOMNode is deprecated and will be removed in the next major '+'release. Instead, add a ref directly to the element you want '+'to reference. Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node');}var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}var didWarnAboutUnmountComponentAtNode=false;function unmountComponentAtNode(container){{if(!didWarnAboutUnmountComponentAtNode){didWarnAboutUnmountComponentAtNode=true;error('unmountComponentAtNode is deprecated and will be removed in the '+'next major release. Switch to the createRoot API. Learn '+'more: https://reactjs.org/link/switch-to-createroot');}}if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}\n\n//# sourceURL=webpack:///./node_modules/react-dom/cjs/react-dom.development.js?");

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function (c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function (c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/react-dom/client.js?");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/react-dom/index.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.3.1';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol[\"for\"]('react.element');\n    var REACT_PORTAL_TYPE = Symbol[\"for\"]('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol[\"for\"]('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol[\"for\"]('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol[\"for\"]('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol[\"for\"]('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol[\"for\"]('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol[\"for\"]('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol[\"for\"]('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"]('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol[\"for\"]('react.memo');\n    var REACT_LAZY_TYPE = Symbol[\"for\"]('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol[\"for\"]('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function isMounted(publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (_typeof(partialState) !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function get() {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function warnAboutAccessingKey() {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function warnAboutAccessingRef() {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (_typeof(element) === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = _typeof(children);\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function get() {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function set(_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function get() {\n              return context._currentValue;\n            },\n            set: function set(_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function get() {\n              return context._currentValue2;\n            },\n            set: function set(_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function get() {\n              return context._threadCount;\n            },\n            set: function set(_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function get() {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function get() {\n              return context.displayName;\n            },\n            set: function set(displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject[\"default\"];\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function get() {\n              return defaultProps;\n            },\n            set: function set(newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function get() {\n              return propTypes;\n            },\n            set: function set(newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : _typeof(render));\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol[\"for\"]('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (_typeof(type) === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : _typeof(type));\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (_typeof(node) !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = _typeof(type);\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function get() {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function enqueueTaskImpl(callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && _typeof(result) === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function then(resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function then(resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function then(resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.act = act;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack:///./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (_typeof(options) === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function performWorkUntilDeadline() {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack:///./node_modules/scheduler/cjs/scheduler.development.js?");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n\n//# sourceURL=webpack:///./node_modules/scheduler/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./public/fonts/Outfit/Outfit-VariableFont_wght.ttf":
/*!**********************************************************!*\
  !*** ./public/fonts/Outfit/Outfit-VariableFont_wght.ttf ***!
  \**********************************************************/
/***/ ((module) => {

eval("module.exports = \"data:font/ttf;base64,AAEAAAAUAQAABABAR0RFRm6cmscAABVAAAAFfUdQT1PUs85NAACUMAAAeABHU1VCyLHsegAAGsAAAAWWSFZBUv80qW4AABAYAAAFJU1WQVLjhebcAAAB2AAAAFBPUy8ycP1uaQAAAigAAABgU1RBVIEuffkAAAL0AAAAnmNtYXBKxX1WAAAG1AAABExmdmFylphpkwAAAogAAABsZ2FzcAAAABAAAAFUAAAACGdseWZJpghEAAAwaAAAY8ZndmFy3rY1igABDDAAAKO8aGVhZClUWlAAAAGgAAAANmhoZWEREg0rAAABfAAAACRobXR4ai5efAAAIFgAAAZ4bG9jYePVy4kAAAOUAAADPm1heHABtgEDAAABXAAAACBuYW1lhfTGjwAACyAAAAT4cG9zdO6M5zoAACbQAAAJl3ByZXBoBoyFAAABTAAAAAe4Af+FsASNAAABAAH//wAPAAEAAAGeALQADgBNAAYAAQAAAAAAAAAAAAAAAAADAAEAAQAAA+j+/AAADfL/hf6eDaIAAQAAAAAAAAAAAAAAAAAAAZ4AAQAAAAEZmp5Irp5fDzz1AAMD6AAAAADc2+X+AAAAAOA6Fyr/hf8CDaIDqQAAAAYAAgAAAAAAAAABAAAAAAAIAAMAJGNwaHQAAAACc3RybwAAAAB4aGd0AAAAAQABAAAADAABAAAAHAABAAIAACAAQAAgAEAAQAAAAwAAAAIAAAABDBMUIBgkAAQCMQBkAAUAAAKKAlgAAABLAooCWAAAAV4AMgEUAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAGZyYWcAwAAN+wID6P78AAAD6AEEAAAAAQAAAAABzAKkAAAAIAAJAAEAAAAQAAIAAQAUAAkACHdnaHQAZAAAAGQAAAOEAAAAAAEBAQIAAABkAAABAwAAAMgAAAEEAAABLAAAAQUAAAGQAAABBgAAAfQAAAEHAAACWAAAAQgAAAK8AAABCQAAAyAAAAEKAAADhAAAAAEAAQAIAAEAAAAUAAkAAAAcAAJ3Z2h0AQEAAAASAB4AKgA2AEYAUgBeAGoAdgABAAAAAAARAGQAAAABAAAAAAEDAMgAAAABAAAAAAEEASwAAAADAAAAAgACAZAAAAK8AAAAAQAAAAABBgH0AAAAAQAAAAABBwJYAAAAAQAAAAABCAK8AAAAAQAAAAABCQMgAAAAAQAAAAABCgOEAAAAAAAAACQAPwBLAFcAfwCLAJcAowCvALsAxwDTAQQBPQFwAXwBvAHIAdQB/QIuAmQClQK1AsEC7QL5AwUDEQMdAykDNQNPA4gDlAOgA6wDxgPnA/MD/wQLBBcEIwQvBDsETgRZBHgEkwSfBLEEvQTJBNUE7wUPBS4FOgVlBXEFfQWJBcEFzQXZBeUF8QY3BkMGhAaQBuEHCgcyB3QHowevB+sH9wg0CEAIiQiVCKEI9wkLCSsJNwlbCWcJcwl/CYsJlwnKCdYJ4gnuCgMKIwovCjsKRwpTCnkKlgqiCq4KugrGCuUK8QscCygLSgt/C5oL1gviC+0MNQxADEsMVwxiDG4MegyFDJEMzwz+DQoNRg1RDV0Nmw3eDeoOLw5pDnUOuw7GDtEO3Q7pDvQPAA8kD3IPfQ/lD/EQFxBEEGAQbBB3EIIQjRCYEKQQtxDCEPARDhEnETMRPxFLEVcRYhF2EbUR2xHnEhoSJhIxEm8SoRKtErgSwxLPEw8TGhNUE18TaxOpE+gUJBREFE8UexSGFMIUzRUVFSAVLBV3FYoVlhWhFcQV0BXbFeYV8RX8Fi0WOBZEFk8WYhaBFo0WmRalFrEW0BbqFvYXARcMFxcXNhdBF2wXdxeDF7kXxRgHGBIYHRgpGDUYQBhMGKsYxhjSGQYZJhkyGV8Zaxl2Ga8ZuxngGewZ+Bo0GoAaoxreGwEbkRySHXYdqR3LHfYeEB5FHnEeox61HuUfJR9CH4IfvR/UIC4gaCB9IK8gyCD4ITohVyGYIdMh6iJEIn4ilSLeIxYjcyOGI7Ej6SQDJAMkAyQDJBkkOSRfJI8knyS8JNolFiVSJVsldyWVJbglxyXWJeIl7iX6JgYmIyZAJnsmtibOJuYm7ib3JzEnayeLJ6snxCfdJ+0n/SgQKB0oMiigKOkpGil8KdoqLSpYKoQqkSqlKvgrTiuEK9IsFSxVLIEsryy+LNEs3iz2LSItNS1ILVwtdS2dLa8twi3lLj4uVS5vLoYuny62Ls8u5i7/LyQvOi9IL1Yvay+LL54vsS/OL/owIDAtME0wbTCTMLUwvTDFMM0w1TDqMPIxBTENMRUxHTElMS0xNTFVMWAxmzHjAAAAAAACAAAAAwAAABQAAwABAAAAFAAEBDgAAABoAEAABQAoAA0ALwA5AH4ArAEHARMBGwEjAScBKwEzATcBPgFIAU0BWwFhAWUBfgHOAhsCNwK8AscC3QMEAwgDDAMSAygehR6eHvMgFCAaIB4gIiAmIDogRCB0IKwhICEiIZMhmSISIhUnE/sC//8AAAANACAAMAA6AKAArgEKARYBHgEmASoBLgE2ATkBQQFKAVABXgFkAWoBzQIYAjcCvALGAtgDAAMGAwoDEgMmHoAenh7yIBMgGCAcICIgJiA5IEQgdCCsISAhIiGQIZYiEiIVJxP7Af//AR8AAADfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+b/7e/swAAAAAAAAAAP53/mQAAOG3AADhLAAAAADhF+EN4Rfg4OC34LjgP+A5AAAAAN9X31LaQQYDAAEAAABmAAAAggEKASIB1AHmAfAB+gH8Af4CCAIKAhQCIgIoAj4CRAJGAm4CcAAAAAAAAAJwAnoCggKGAAAAAAKGAAACjgAAAo4CkgAAAAAAAAAAAAAAAAAAAAAChgKMAAAAAAAAAAAAAAEtATQBUgE7AWMBdAFWAVMBQgFDAToBaAEwAT4BLwE8ATEBMgFuAWwBbQE2AVUAAQANAA4AEwAXACAAIQAlACcAMAAxADMAOAA5AD8ASQBLAEwAUABWAFkAYwBkAGkAagBvAUYBPQFHAXIBQQGPAHYAggCDAIgAjACVAJYAmgCcAKUApwCpAK4ArwC1AL8AwQDCAMYAzADPANkA2gDfAOAA5QFEAV0BRQFwAS4BNQFhAWUBYgFmAV4BWAGNAVkBDQFOAXEBWgGXAVwBbwEpASoBkAFzAVcBOAGYASgBDgFPASYBJQEnATcABwACAAUACwAGAAoADAARAB0AGAAaABsALQApACoAKwAUAD0AQwBAAEEARwBCAWoARgBeAFoAXABdAGsASgDLAHwAdwB6AIAAewB/AIEAhgCSAI0AjwCQAKEAngCfAKAAiQCzALkAtgC3AL0AuAFrALwA1ADQANIA0wDhAMAA4wAIAH0AAwB4AAkAfgAPAIQAEgCHABAAhQAVAIoAFgCLAB4AkwAcAJEAHwCUABkAjgAiAJcAJACZACMAmAAmAJsALgCjAC8ApAAsAJ0AKACiADIAqAA0AKoANgCsADUAqwA3AK0AOgCwADwAsgA7ALEAPgC0AEUAuwBEALoASAC+AE0AwwBPAMUATgDEAFEAxwBTAMkAUgDIAFcAzQBgANYAWwDRAGIA2ABfANUAYQDXAGYA3ABsAOIAbQBwAOYAcgDoAHEA5wAEAHkAVADKAFgAzgGUAY4BlQGZAZYBkQF/AYABgwGHAYgBhQF+AX0BhgGBAYQAaADeAGUA2wBnAN0AbgDkAUwBTQFIAUoBSwFJAXsBdQF3AXkBfAF2AXgBegAAABsBSgADAAEECQAAAKgDBgADAAEECQABABYC8AADAAEECQACAA4C4gADAAEECQADACwCtgADAAEECQAEABYC8AADAAEECQAFADoCfAADAAEECQAGABYCZgADAAEECQAIABACVgADAAEECQAJACQCMgADAAEECQALAC4CBAADAAEECQAMACYB3gADAAEECQANASIAvAADAAEECQAOADYAhgADAAEECQAQAAwAegADAAEECQARAAgAcgADAAEECQAZAAwAegADAAEECQEAAAgAagADAAEECQEBAAwAXgADAAEECQECAAgAcgADAAEECQEDABQASgADAAEECQEEAAoAQAADAAEECQEFAA4C4gADAAEECQEGAAwANAADAAEECQEHABAAJAADAAEECQEIAAgAHAADAAEECQEJABIACgADAAEECQEKAAoAAABCAGwAYQBjAGsARQB4AHQAcgBhAEIAbwBsAGQAQgBvAGwAZABTAGUAbQBpAEIAbwBsAGQATQBlAGQAaQB1AG0ATABpAGcAaAB0AEUAeAB0AHIAYQBMAGkAZwBoAHQAVwBlAGkAZwBoAHQAcwBzADAAMQBUAGgAaQBuAE8AdQB0AGYAaQB0AGgAdAB0AHAAcwA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADEALgAxAC4AIABUAGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGkAcwAgAGEAdgBhAGkAbABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6ACAAaAB0AHQAcABzADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAdwB3AHcALgByAGYAdQBlAG4AegBhAGwAaQBkAGEALgBjAG8AbQB3AHcAdwAuAGYAcgBhAGcAdAB5AHAAZQBmAG8AdQBuAGQAcgB5AC4AeAB5AHoAUgBvAGQAcgBpAGcAbwAgAEYAdQBlAG4AegBhAGwAaQBkAGEAZgByAGEAZwBUAFkAUABFAE8AdQB0AGYAaQB0AC0AVABoAGkAbgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMAAwADsAZwBmAHQAbwBvAGwAcwBbADAALgA5AC4AMgA3AF0AMQAuADEAMAAwADsAZgByAGEAZwA7AE8AdQB0AGYAaQB0AC0AVABoAGkAbgBSAGUAZwB1AGwAYQByAE8AdQB0AGYAaQB0ACAAVABoAGkAbgBDAG8AcAB5AHIAaQBnAGgAdAAgADIAMAAyADEAIABUAGgAZQAgAE8AdQB0AGYAaQB0ACAAUAByAG8AagBlAGMAdAAgAEEAdQB0AGgAbwByAHMAIAAoAGgAdAB0AHAAcwA6AC8ALwBnAGkAdABoAHUAYgAuAGMAbwBtAC8ATwB1AHQAZgBpAHQAaQBvAC8ATwB1AHQAZgBpAHQALQBGAG8AbgB0AHMAKQABAAAAAANUAAAAFAAAAAAAAAAAABcBngFLAWcBZwFnAWcBZwFnAWcBZwFnAWcBZwF0ASUBDgEOAQ4BDgEOATIBYwEyAWEBNQE1ATUBNQE1ATUBNQE1ATUBLQEqASoBKgEqAWkBgQF4AgABeAF4AXgBeAF4AXgBeAErAWsBawEeAR4BHgEeAQgBSgFwAXABcAFwAXABcAEvAS8BLwEvAS8BLwEvAS8BLwEHASMBIwFMARsBGwEbARsBOgE6AToBOgE6AUIBCwELAQsBbwFvAW8BbwFvAW8BbwFvAW8BbwFyAT8BPwE/AT8BPwFtAWwBbAFsAWwBbAFmAWYBZgFmASkBKAFoARkBGQEZARkBGQEZARkBGQEZARkBGQEDARkBHQEdAR0BHQEdARkBJAFdAUUBHwEfAR8BHwEfAR8BHwEfAR8BWwEQARABEAEQAVEBUQF/AXoBegF6AXoBegIUAXoBfwGFAYUBjAGMAXwBfAIWAXwBEgFlAVEBUQFRAVEBUQFRARYBFgEWARYBFgEWARYBFgEWAQEBGQEZARcBZAFkAWQBZAFQAVABUAFQAVABXgF9AhIBfQE9AT0BPQE9AT0BPQE9AT0BPQE9AScBWAFYAVgBWAFYAWIBVwFXAVcBVwFXAVwBXAFcAVwBCQFIAUgBSAFIAUgBSAFIAUgBSAF2AY4BjgFTATkBOQE5ATkBOQE5AQYBeQIBAXkCAwIGAgcCCQIIAwIDAwMEAXEBhwIEAgwBNwEuASYBcwE0AUQBPAFUASQBFQEgASQCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAZABiwGJAY0BbgFSAUcBLAAAAQoBCgExATsBMwABAg8BOAFDATYBDAILAYMBPgFAAYABgAEwAVoBdwEAAREBEwFPAU8BTQFNATsCEQITAhUBRgFOAg0CDQFJAUkCFwFfAhABAgF+AYYBGgEFAQQBdQEcAVUBVQGKAXsBagMBAQ8BDQFBARgBgAFgAWABYAFgAWABYAFgAWABYAFgASIBFAEhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhgCCgGEAYQDAAGIAYgBiAGCAg4BjwFWAgUBWQFhAWoBDwABAAABwQAEAAABtwAAAIsAAAA2AAAAGAAFAAIAAgAAAAEAjAE3AI0AkACOAVgAkgHTALIB+gAZAAEAAgABAAAArw4AhCgAgy0Aki0AmTQAmjgApTwAjD4AlD4ApT8AiEIAiUIAk0UAi0cAgVIA3VIAoVQAjlUAvVcAmlsAzlsAml0A1V0ApGgAsGoAkQAAAAIAAAABodHK1cvxzerYwN3C3ubf9eDJ4fvizucP6vTs3+z48RfyA/IH887zCPMV9f/2D/YU9jH3Ffcl9yb4//gK+A74E/gU+C35F/kp+hD7IPwR/DH9OP0+/hf+Sf/2/y8BCgEZAgQCFQIeAigCMAIzA/UDDwMyBDEEOQUTBRgFMQYDBi4GMAkZCTQKLgowCwsLHwwDDCQMJwwsDfUNCw0cDR8NLA1EDjgPDg8kDy0PMg9IEC8QTREkES8RUhJNEm4ULxUlFTUVPxVLFjIXPBgwGD0YTRhjGT0aBBpbGzgbPRwYHDQcRR5hIkQiUCM7I2AkLyQwJVgoTyhiKUIpYypUKlUqYCsJL1MwRjFCMW0xbjMxM1szZTVANX42RzZ7OUU7d0JSXW4AAgAAAAEAAQAWAAEAAgAAIABAACAAQABAAAAAAAABAAMB9AAAABIAAAKmAAACvgAcAAwB0gHCAbIBogGSAUoA2ABmAFYARgA2ACYAAgABAQEBDAAAAAEABAADASwABgABANeAAAABAAQAAwFEAAYAAQDEgAAAAQAEAAMBNgAGAAEAwIAAAAEABAADAU4ABgABAJGAAAAIAGYAWgBOAEIANgAqAB4AEgADC78ABgADAASAAAADCkcABgADAAOAAAADCM8ABgACACOAAAADB1cABgACABmAAAADBeAABgACABCAAAADBGgABgACAAaAAAADAvAABgABANyAAAADAXgABgABAK6AAAAIAGYAWgBOAEIANgAqAB4AEgADDGUABgADAAGAAAADCtkABgACAB2AAAADCUwABgACABiAAAADB78ABgACABGAAAADBjMABgACAAqAAAADBKYABgACAAOAAAADAxkABgABANaAAAADAY0ABgABAJKAAAAFADwAMAAkABgADAADBycABgACACGAAAADBbkABgACABeAAAADBEoABgACAA6AAAADAtwABgABAOOAAAADAW4ABgABALyAAAABAAQAAwEHAAYAAQDSgAAAAQAEAAMBBwAGAAEA04AAAAEABAADASwABgABAM6AAAABAAQAAwEHAAYAAQDPgAAAAQAEAAMBRAAGAAEAtYAAAAIAHQABAAsAAQAOAB8AAQAhACQAAQAnAC8AAQAxADcAAQA5AEcAAQBMAFQAAQBWAGIAAQBkAGgAAQBqAHIAAQB2AIEAAQCDAIcAAQCMAJQAAQCWAJkAAQCcAKQAAQCmAK0AAQCvALsAAQC9AL4AAQDCAMoAAQDMANgAAQDaAN4AAQDgAPIAAQD0APUAAQD3AQAAAQEBAQwAAgFbAVsAAQFfAV8AAQF9AYEAAwGDAYwAAwABAAEAAAAIAAIAAgF9AYEAAAGDAYkABQABAAACrwAEAAACnwAAALkAAAA6AAAAGAAGAAIAAgAAAAEAgAE2AIIBnwCDAaQAiwGKAJ4BwgCgAccAJwABAAIAAQAAAJYVAIEoAIwxAJwxALY5AIM7AKg7AIA8AJA8AIVBAM9BALREAMRFAKxHAKxIAOpJAOBPAQRRAMhSAIJYANdYAP1ZAIZcAOVeATdhARpjAJZkAJpoAIxuAWtx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AQ0BDgENAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AEOAP0A/gD/AQABGgEfASABIQEiASMBDwEQAREBEgETARQBFQEWARcBGAFgAAIADgABAAEAAAA/AD8AAQB2AHYAAgCBAIEAAwCMAJQABACWAJYADQCnAKgADgCuALUAEAC+AL4AGADMAM4AGQEPAQ8AHAEUARgAHQEaASMAIgFWAVYALAAAAqQAYwKmADICpgAyAqYAMgKmADICpgAyAqYAMgKmADICpgAyAqYAMgKmADICpgAyA7MAMgJzAGMCvwBCAr8AQgK/AEICvwBCAr8AQgLiAGMC4gAOAuIAYwLiAAACTABjAkwAYwJMAGMCTABjAkwAYwJMAGMCTABjAkwAYwJMAGMCNwBjAwYAQgMGAEIDBgBCAwYAQgKvAGMCmQAAAOYAYwJTAGMA5gAhAOb/2wDm//4A5gBTAOYAAwDm//4A5gAeAfAAMQKGAGMChgBjAi4AYwIuAGMCLgBjAi4AYwKMAFADPgBjArEAYwKxAGMCsQBjArEAYwKxAGMCsQBjAxkAQgMZAEIDGQBCAxkAQgMZAEIDGQBCAxkAQgMZAEEDGQBCBJ4AQgJjAGMCYwBjAycAQgJ9AGMCfQBjAn0AYwJ9AGMCKAAyAigAMgIoADICKAAyAigAMgLFAGMChAAxAoQAMQKEADEClgBaApYAWgKWAFoClgBaApYAWgKWAFoClgBaApYAWgKWAFoClgBaApYAMgPQADMD0AAzA9AAMwPQADMD0AAzAp8AMQKFADAChQAwAoUAMAKFADAChQAwAjUANAI1ADQCNQA0AjUANARSADEESAAxAu4AMQJNADICTQAyAk0AMgJNADICTQAyAk0AMgJNADICTQAyAk0AMgJNADICTQAyA8sAMgJNAFAB7wAyAe8AMgHvADIB7wAyAe8AMgJNADMCOAA5AvAAMwJNADMCHgAyAh4AMgIeADICHgAyAh4AMgIeADICHgAyAh4AMgIeADIBggAfAk0AMwJNADMCTQAzAk0AMwIZAFACGQAAAMAAQADAAFAAwAAOAMD/yADA/+sAwP/wAYEAQADA/+sAwAALAMH/hQDB/4UByQBQAckAUAC/AFAAvwANAUkAUAC/ADYBnwBQA0UAUAIZAFACGQBQAhkAUAIZAFACGQBQAhkAUAI9ADICPQAyAj0AMgI9ADICPQAyAj0AMgI9ADICPQAsAj0AMgPXADICTQBQAk0AUAJOADMBkgBQAZIAUAGSADIBkgA2AaEAJgGhACYBoQAmAaEAJgGhACYCLgBQAVAAHwGMAB8BUAAfAgAARQIAAEUCAABFAgAARQIAAEUCAABFAgAARQIAAEUCAABFAgAARQICAB8C4gAhAuIAIQLiACEC4gAhAuIAIQHoAB8B9gAgAfYAIAH2ACAB9gAgAfYAIAGxACMBsQAjAbEAIwGxACMDogAyAfUAMgH1ADIB9QAyAfUAMgH1ADIB9QAyAfUAMgH1ADIB9QAyAd4AJQG8AFABvABQAzkARgIKAEUCCgBFAgoARQIKAEUCCgBFAgoARQOuADIBpAAfAaQAHwGkAB8CiAAfAg4AHwJXAB8CDgAfAg4AHwiVADIN8gAyDTcAMgKdAFACbABQAogAHwJXAB8BYAAcAVcAHAKTAEEBQQAtAhsAMAISAC8CUgAwAhIAMAI4ADkCFQAtAiwAOwI4ADkBQQAxAk4AKgJOAFgCTgBDAk4ARQJOADACTgBHAk4AQgJOAEICTgBIAk4AQgJOADgCdQA4AnwAOAJzADgA8AAtAUUAMAFGAC8BXwAwAlgAAADmAAAA5gAAASAAaAEPAGIBDQBfAQ0AXwKwAGgBAwBYAQMAWAH3AD0B+QBIAFAAAAElAEoB5QBGAnsAQAFmAB4BZgAeAcsAUAIYAFADOQBQAkAAUAE5AEABOAAuATkALQE5AC8BSABfAUgALwEPAGIBiwBiAWwATAFrAFIA8ABMAO8AUgGVADUBlQA0AQkANQEJADQBQgBbAN0AWwLLACADFgBWAnMAUAKcAE4CDABSA1sAVQJWAFsCmwAYAZAANwELAHcBCwB3Am8AGAJeAD8B9QA1AcoAFAJXAFIC5AAiAmQATgKMAFYBZgAeAg4ASwIOAEsCDgBVAg4ASwIOAEsCDgBLAg4ASwIOAEsCDgBFAg4ASwHKAEsCTQB3ApoATgKSAGMCkgBjApIARQKSAGMCkgBjApIAYwKSADECkgBjAAAAPAAAAFoAAAAoAAAAKAAAACgAAABaAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAWAAAAJAFiADwA9ABaAPQAKAD0ACgBIgAoAYAAKAGAACgBgAAoARsAKAGKACgBhgAoAQQAFgDeACQA8wBIAuIAAAH1ADUCVwBSAAIAAAAAAAD/nAAyAAAAAAAAAAAAAAAAAAAAAAAAAAABngAAACQAyQECAQMAxwBiAK0BBAEFAGMArgCQACUAJgD9AP8AZAEGACcA6QEHAQgAKABlAQkAyADKAQoAywELAQwAKQAqAPgBDQEOACsBDwAsARAAzADNAM4A+gDPAREBEgAtAC4BEwAvARQBFQEWAOIAMAAxARcBGAEZAGYBGgAyANAA0QBnANMBGwEcAJEArwCwADMA7QA0ADUBHQEeAR8ANgEgAOQA+wEhASIANwEjASQAOADUASUA1QBoANYBJgEnASgBKQA5ADoBKgErASwBLQA7ADwA6wEuALsBLwA9ATAA5gExATIBMwE0AEQAaQE1ATYAawBsAGoBNwE4AG4AbQCgAEUARgD+AQAAbwE5AEcA6gE6AQEASABwATsAcgBzATwAcQE9AT4ASQBKAPkBPwFAAEsBQQBMANcAdAB2AHcAdQFCAUMBRABNAUUATgFGAE8BRwFIAUkA4wBQAFEBSgFLAUwAeAFNAFIAeQB7AHwAegFOAU8AoQB9ALEAUwDuAFQAVQFQAVEBUgBWAVMA5QD8AVQAiQBXAVUBVgBYAH4BVwCAAIEAfwFYAVkBWgFbAFkAWgFcAV0BXgFfAFsAXADsAWAAugFhAF0BYgDnAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXsBfAF9AX4AwADBAX8BgAGBAYIBgwGEAYUAnQCeABMAFAAVABYAFwAYABkAGgAbABwBhgGHAYgBiQGKAYsBjAGNAY4BjwGQALwA9AD1APYBkQGSAZMBlAGVAAMBlgARAA8AHQAeAKsABACjACIAogDDAIcADQAGABIAPwAQALIAswBCAAsADABeAGAAPgBAAMQAxQC0ALUAtgC3AKkAqgC+AL8ABQAKAZcAIwAJAIgAhgCLAIoAjACDAF8A6AGYAZkAhAC9AAcBmgCFAJYBmwAOAO8A8AC4ACAAIQAfAJMAYQCkAEEBnAAIAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AI4A3ABDAI0A3wDYAOEA2wDdANkA2gDeAOABtQG2AbcBuAZBYnJldmUHdW5pMDFDRAdBbWFjcm9uB0FvZ29uZWsKQ2RvdGFjY2VudAZEY2Fyb24GRGNyb2F0BkVjYXJvbgpFZG90YWNjZW50B0VtYWNyb24HRW9nb25lawd1bmkwMTIyCkdkb3RhY2NlbnQESGJhcgJJSgdJbWFjcm9uB0lvZ29uZWsHdW5pMDEzNgZMYWN1dGUGTGNhcm9uB3VuaTAxM0IGTmFjdXRlBk5jYXJvbgd1bmkwMTQ1A0VuZw1PaHVuZ2FydW1sYXV0B09tYWNyb24GUmFjdXRlBlJjYXJvbgd1bmkwMTU2BlNhY3V0ZQd1bmkwMjE4B3VuaTFFOUUGVGNhcm9uB3VuaTAyMUEGVWJyZXZlDVVodW5nYXJ1bWxhdXQHVW1hY3JvbgdVb2dvbmVrBVVyaW5nBldhY3V0ZQtXY2lyY3VtZmxleAlXZGllcmVzaXMGV2dyYXZlC1ljaXJjdW1mbGV4BllncmF2ZQZaYWN1dGUKWmRvdGFjY2VudANUX1QDVF9oA1RfbAZhYnJldmUHdW5pMDFDRQdhbWFjcm9uB2FvZ29uZWsKY2RvdGFjY2VudAZkY2Fyb24GZWNhcm9uCmVkb3RhY2NlbnQHZW1hY3Jvbgdlb2dvbmVrB3VuaTAxMjMKZ2RvdGFjY2VudARoYmFyAmlqB2ltYWNyb24HaW9nb25lawd1bmkwMjM3B3VuaTAxMzcGbGFjdXRlBmxjYXJvbgd1bmkwMTNDBm5hY3V0ZQZuY2Fyb24HdW5pMDE0NgNlbmcNb2h1bmdhcnVtbGF1dAdvbWFjcm9uBnJhY3V0ZQZyY2Fyb24HdW5pMDE1NwZzYWN1dGUHdW5pMDIxOQZ0Y2Fyb24HdW5pMDIxQgZ1YnJldmUNdWh1bmdhcnVtbGF1dAd1bWFjcm9uB3VvZ29uZWsFdXJpbmcGd2FjdXRlC3djaXJjdW1mbGV4CXdkaWVyZXNpcwZ3Z3JhdmULeWNpcmN1bWZsZXgGeWdyYXZlBnphY3V0ZQp6ZG90YWNjZW50B2FlLnNzMDEGZS5zczAxC2VhY3V0ZS5zczAxC2VjYXJvbi5zczAxEGVjaXJjdW1mbGV4LnNzMDEOZWRpZXJlc2lzLnNzMDEPZWRvdGFjY2VudC5zczAxC2VncmF2ZS5zczAxDGVtYWNyb24uc3MwMQxlb2dvbmVrLnNzMDEGZy5zczAxBmsuc3MwMQx1bmkwMTM3LnNzMDEGbS5zczAxBm4uc3MwMQtuYWN1dGUuc3MwMQtuY2Fyb24uc3MwMQx1bmkwMTQ2LnNzMDELbnRpbGRlLnNzMDEIZW5nLnNzMDEHb2Uuc3MwMQZ0LnNzMDELdGNhcm9uLnNzMDEMdW5pMDIxQi5zczAxA2ZfZgNmX2oDZl90C29fdV90X2ZfaV90EW9fdV90X2ZfaV90X3RfZV9kEW9fdV90X2ZfaV90X3RfZV9yA3JfZgNyX3QDdF9mA3RfdAhvbmUuc3MwMQd6ZXJvLnRmBm9uZS50ZgZ0d28udGYIdGhyZWUudGYHZm91ci50ZgdmaXZlLnRmBnNpeC50ZghzZXZlbi50ZghlaWdodC50ZgduaW5lLnRmB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQCQ1IHdW5pMDBBMAd1bmkyNzEzB3VuaTIxMjAOYW1wZXJzYW5kLnNzMDEERXVybwd1bmkyMjE1B3VuaTAwQjUHYXJyb3d1cAd1bmkyMTk3CmFycm93cmlnaHQHdW5pMjE5OAlhcnJvd2Rvd24HdW5pMjE5OQlhcnJvd2xlZnQHdW5pMjE5Ngd1bmkwMzA4B3VuaTAzMDcJZ3JhdmVjb21iCWFjdXRlY29tYgd1bmkwMzBCC3VuaTAzMEMuYWx0B3VuaTAzMDIHdW5pMDMwQwd1bmkwMzA2B3VuaTAzMEEJdGlsZGVjb21iB3VuaTAzMDQHdW5pMDMxMgd1bmkwMzI2B3VuaTAzMjcHdW5pMDMyOAphcG9zdHJvcGhlF0Rjcm9hdC5CUkFDS0VULnZhckFsdDAxFWNlbnQuQlJBQ0tFVC52YXJBbHQwMRdkb2xsYXIuQlJBQ0tFVC52YXJBbHQwMQAABABjAAACQQKkAAMABwALAA8AADMRIRElIREhFzcXBxMXASdjAd7+QgGe/mJLEfcSBxL+/BICpP1cHwJmwBH3EQEPEv78EgAAAgAyAAACdAKkAAcACwAAMwEzASMBMwE3NSEVMgETHgERI/77D/75UQFdAqT9XAKI/XjfHR3//wAyAAACdAOYAiYAAQAAAAcBgADZANj//wAyAAACdAN2AiYAAQAAAAcBhQCTANgAAwAyAAACdAOYAAcACwATAAAzATMBIwEzATc1IRUDFwcj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DaQNrgAADbgNrgAADZoNrgAADYoNgA1wDWANVg1GDTwNgA1wDTINgA1wDSgNgA1wDR4NgA1wDRQNgA1wDQoNgA1wDYoNgA1wAAAM+gAAAAAM+gAADOoM4AAADNYM4AAADOoM4AAADOoM4AAADMYMvAAADLIMqAAADJ4MqAAADJQMqAAADLIMqAAADIoMqAAAAAAAAAx6DbgNrgxqDGANrgxqDFYNrgxqDEwNrgxqDEINrgxqDDgNrgxqDC4NrgxqDB4MFAwEC/oNrgxqC+oL2gAAC9AL2gAAC8YL2gAAC+oL2gAAC7YLpgAAC5wLpgAAC5ILpgAAC7YLpgAAC7YLpgAAC4ILeAAAC24LeAAAC4ILeAAAC2QLWgtKC0ALWgtKCzYLWgtKCywLWgtKCyILWgtKCxgLWgtKCw4LWgtKCwQLWgtKC2QLWgtKCvQLWgtKCuQK2gAACtAK2gAACsYK2gAACrwK2gAACrIK2gAACqgKngAACpQKngAACooKngAACoAKngAACnYKngAACmYAAAAAClwAAAAAClIAAAAACkgAAAAACjgKKAoYCggKKAoYCfgKKAoYCegKKAoYCegKKAoYCdgKKAoYCcgKKAoYCbgKKAoYCjgKKAoYCagKKAoYCZgKKAoYCY4JhAAACXoJhAAACXAJhAAACY4JhAAACWAJhAAACVAJRgk2CSwJRgk2CSIJRgk2CSIJRgk2CRgJRgk2CQ4JRgk2CQQJRgk2CPoJRgk2CVAJRgk2CjgI6gAACfgI6gAACNoI6gAACNAI6gAAAAAIwAiwCKYIwAiwCJwIwAiwCJIIwAiwCIgIwAiwCH4IwAiwAAAIwAiwCHQIwAiwAAAIwAiwCGQIWghKAAAIOgAAAAAIOgAACCoIGgAACBAIGgAACCoIGgAACCoIGgAAB/oH6gAAB9oH0AAAB8YH0AAAB7wH0AAAB9oH0AAAB7IH0AAAB9oH0AAAB6IHmAeIB34HmAeIB3QHmAeIB2oHmAeIB2AHmAeIB1YHmAeIB0wHmAeIB0IHmAeIBzIIGgAABygIGgAABx4IGgAABzIIGgAABw4G/gAABvQG/gAABuoG/gAABw4G/gAABw4G/gAABtoG0AAABtoG0AAABtoG0AAABsAGtgamBpwGtgamBpIGtgamBogGtgamBn4GtgamBnQGtgamBmoGtgamBmAGtgam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/+4AAABa/+4AAABb/+4AAABc/+4AAABd/+4AAABe/+4AAABf/+4AAABg/+4AAABh/+4AAABi/+4AAABj/9wAAABk/+QAAABp/9IAAABq/9YAAABr/9YAAABs/9YAAABt/9YAAABu/9YAAABv/+4AAABz/8UNvgB0/8UNvgB1/8UNvgB2/84jdAB3/84jdAB4/84jdAB5/84jdAB6/84jdAB7/84jdAB8/84jdAB9/84jdAB+/84jdAB//84jdACA/84jdACB/84jdACC/+4AAACD/84jdACE/84jdACF/84jdACG/84jdACH/84jdACI/84jdACK/84jdACL/84jdACM/84jdACN/84jdACO/84jdACP/84jdACQ/84jdACR/84jdACS/84jdACT/84jdACU/84jdACV/8oAAACW/84jdACX/84jdACY/84jdACZ/84jdACa/+4AAACn/+4AAACo/+4AAACp/+4AAACq/+4AAACr/+4AAACs/+4AAACt/+4AAACu/+gAAACv/+gAAACw/+gAAACx/+gAAACy/+gAAACz/+gAAAC0/+gAAAC1/84jdAC2/84jdAC3/84jdAC4/84jdAC5/84jdAC6/84jdAC7/84jdAC8/84jdAC9/84jdAC+/84jdAC//+gAAADA/+gAAADB/84jdADC/+gAAADD/+gAAADE/+gAAADF/+gAAADG/+gAAADM/8oAAADN/8oAAADO/8oAAADP/+AAAADQ/+AAAADR/+AAAADS/+AAAADT/+AAAADU/+AAAADV/+AAAADW/+AAAADX/+AAAADY/+AAAADZ/8YAAADa/8wAAADf/9oAAADg/8YAAADh/8YAAADi/8YAAADj/8YAAADk/8YAAADl/+gAAADp/84jdADq/84jdADr/84jdADs/84jdADt/84jdADu/84jdADv/84jdADw/84jdADx/84jdADy/84jdADz/+YAAAD0/+4AAAD1/+4AAAD2/+gAAAD3/+gAAAD4/+gAAAD5/+gAAAD6/+gAAAD7/+gAAAD8/+gAAAD9/84jdAD+/8oAAAEB/8oAAAEC/8oAAAED/8oAAAEE/8oAAAEF/8oAAAEG/+AAAAEH/+AAAAEI/+AAAAEJ/+gAAAEK/+gAAAE+/7oFfgFL/+gAAAFN/+gAAAFV/84jdAFW//gAAAFd//IAAAFg//IAAAGa/+gAAAGb//IAAAABAG2AAACeAA7/2iP6AA//2iP6ABD/2iP6ABH/2iP6ABL/2iP6ACH/2iP6ACL/2iP6ACP/2iP6ACT/2iP6ADD/jB3wAD//2iP6AED/2iP6AEH/2iP6AEL/2iP6AEP/2iP6AET/2iP6AEX/2iP6AEb/2iP6AEf/2iP6AEj/2iP6AEv/2iP6AFD/3B+CAFb/2h+OAFf/2h+OAFj/2h+OAGP/5AAAAGT/5AAAAGn/5AAAAGr/3AAAAGv/3AAAAGz/3AAAAG3/3AAAAG7/3AAAAG//7gAAAHP/2h+OAHT/2h+OAHX/2h+OAHb/rAe6AHf/rAe6AHj/rAe6AHn/rAe6AHr/rAe6AHv/rAe6AHz/rAe6AH3/rAe6AH7/rAe6AH//rAe6AID/rAe6AIH/rAe6AIP/rAe6AIT/rAe6AIX/rAe6AIb/rAe6AIf/rAe6AIj/rAe6AIr/rAe6AIv/rAe6AIz/rAe6AI3/rAe6AI7/rAe6AI//rAe6AJD/rAe6AJH/rAe6AJL/rAe6AJP/rAe6AJT/rAe6AJX/3AAAAJb/rAe6AJf/rAe6AJj/rAe6AJn/rAe6AK7/wAAAAK//wAAAALD/wAAAALH/wAAAALL/wAAAALP/wAAAALT/wAAAALX/rAe6ALb/rAe6ALf/rAe6ALj/rAe6ALn/rAe6ALr/rAe6ALv/rAe6ALz/rAe6AL3/rAe6AL7/rAe6AL//wAAAAMD/wAAAAMH/rAe6AML/wAAAAMP/wAAAAMT/wAAAAMX/wAAAAMb/tAAAAMz/3AAAAM3/3AAAAM7/3AAAAM//zAAAAND/zAAAANH/zAAAANL/zAAAANP/zAAAANT/zAAAANX/zAAAANb/zAAAANf/zAAAANj/zAAAANn/wB3wANr/yB+OAN//wgAAAOD/wB3wAOH/wB3wAOL/wB3wAOP/wB3wAOT/wB3wAOX/xgAAAOn/rAe6AOr/rAe6AOv/rAe6AOz/rAe6AO3/rAe6AO7/rAe6AO//rAe6APD/rAe6APH/rAe6APL/rAe6APP/vAAAAPb/wAAAAPf/wAAAAPj/wAAAAPn/wAAAAPr/wAAAAPv/wAAAAPz/wAAAAP3/rAe6AP7/3AAAAQH/3AAAAQL/3AAAAQP/3AAAAQT/3AAAAQX/3AAAAQb/zAAAAQf/zAAAAQj/zAAAAQn/wAAAAQr/wAAAAS//wB3qATD/wB3qATH/0gg0ATL/0gg0ATYAACM8ATz/4AAAAT7/3AO2AVX/rAe6AVb/5AAAAWD/5gAAAAEACoAAAKoAAf+eIEoAAv+eIEoAA/+eIEoABP+eIEoABf+eIEoABv+eIEoAB/+eIEoACP+eIEoACf+eIEoACv+eIEoAC/+eIEoADP+eIEoADv/QEbQAD//QEbQAEP/QEbQAEf/QEbQAEv/QEbQAIf/QEbQAIv/QEbQAI//QEbQAJP/QEbQAMP96H3oAP//QEbQAQP/QEbQAQf/QEbQAQv/QEbQAQ//QEbQARP/QEbQARf/QEbQARv/QEbQAR//QEbQASP/QEbQAS//QEbQAUP/MGjQAVv/IBIQAV//IBIQAWP/IBIQAY//eAAAAZP/kAAAAaf/cAAAAav/gAAAAa//gAAAAbP/gAAAAbf/gAAAAbv/gAAAAb//oAAAAc//IBIQAdP/IBIQAdf/IBIQAdv+WG9IAd/+WG9IAeP+WG9IAef+WG9IAev+WG9IAe/+WG9IAfP+WG9IAff+WG9IAfv+WG9IAf/+WG9IAgP+WG9IAgf+WG9IAg/+WG9IAhP+WG9IAhf+WG9IAhv+WG9IAh/+WG9IAiP+WG9IAiv+WG9IAi/+WG9IAjP+WG9IAjf+WG9IAjv+WG9IAj/+WG9IAkP+WG9IAkf+WG9IAkv+WG9IAk/+WG9IAlP+WG9IAlf/SAAAAlv+WG9IAl/+WG9IAmP+WG9IAmf+WG9IArv+sDEQAr/+sDEQAsP+sDEQAsf+sDEQAsv+sDEQAs/+sDEQAtP+sDEQAtf+WBAQAtv+WG9IAt/+WG9IAuP+WG9IAuf+WG9IAuv+WG9IAu/+WG9IAvP+WG9IAvf+WG9IAvv+WG9IAv/+sDEQAwP+sDEQAwf+WG9IAwv+sDEQAw/+sDEQAxP+sDEQAxf+sDEQAxv+gAAAAzP/SAAAAzf/SAAAAzv/SAAAAz//AAAAA0P/AAAAA0f/AAAAA0v/AAAAA0//AAAAA1P/AAAAA1f/AAAAA1v/AAAAA1//AAAAA2P/AAAAA2f/AAAAA2v/KAAAA3/+YAAAA4P/AAAAA4f/AAAAA4v/AAAAA4//AAAAA5P/AAAAA5f+2AAAA6f+WG9IA6v+WG9IA6/+WG9IA7P+WG9IA7f+WG9IA7v+WG9IA7/+WG9IA8P+WG9IA8f+WG9IA8v+WG9IA8/+gAAAA9v+sDEQA9/+sDEQA+P+sDEQA+f+sDEQA+v+sDEQA+/+sDEQA/P+sDEQA/f+WG9IA/v/SAAABAf/SAAABAv/SAAABA//SAAABBP/SAAABBf/SAAABBv/AAAABB//AAAABCP/AAAABCf+sDEQBCv+sDEQBL/+mGigBMP+mGigBMf+0A/4BMv+0A/4BNgAAH4ABPP/gAAABPv+2H8oBVf+WG9IBVv/kAAABYP/cAAAAAQB+gAAAAQAggAAAEAAw/2IAhgBQ/8oAgABj/8gAegBk/9oXyABp/8UAdABv/8wAbgDG/4AcLgDa/4QAegDf/3IWGADl/4AAaADz/4oAAAEt//AAAAE2AAQDfAE8/9AAAAE+/54AYgFW/+QAAAABAL+AAAABALiAAAABAIuAAAABAISAAAABAKaAAAABAHmAAAABAIKAAAB7AAH/6BosAAL/6BosAAP/6BosAAT/6BosAAX/6BosAAb/6BosAAf/6BosAAj/6BosAAn/6BosAAr/6BosAAv/6BosAAz/6BosAA7/+AL2AA//+AL2ABD/+AL2ABH/+AL2ABL/+AL2ACH/+AL2ACL/+AL2ACP/+AL2ACT/+AL2ADD/0hWeAD//+AL2AED/+AL2AEH/+AL2AEL/+AL2AEP/+AL2AET/+AL2AEX/+AL2AEb/+AL2AEf/+AL2AEj/+AL2AEv/+AL2AFD/7gAAAFb/2BrkAFf/2BrkAFj/2BrkAFkADAAAAFoADAAAAFsADAAAAFwADAAAAF0ADAAAAF4ADAAAAF8ADAAAAGAADAAAAGEADAAAAGIADAAAAGP/7BdIAGT/8BuuAGn/6gLwAGr/0gLwAGv/0gLwAGz/0gLwAG3/0gLwAG7/0gLwAHP/2BrkAHT/2BrkAHX/2BrkAHb/9Bs6AHf/9Bs6AHj/9Bs6AHn/9Bs6AHr/9Bs6AHv/9Bs6AHz/9Bs6AH3/9Bs6AH7/9Bs6AH//9Bs6AID/9Bs6AIH/9Bs6AIP/9Bs6AIT/9Bs6AIX/9Bs6AIb/9Bs6AIf/9Bs6AIj/9Bs6AIr/9Bs6AIv/9Bs6AIz/9Bs6AI3/9Bs6AI7/9Bs6AI//9Bs6AJD/9Bs6AJH/9Bs6AJL/9Bs6AJP/9Bs6AJT/9Bs6AJb/9Bs6AJf/9Bs6AJj/9Bs6AJn/9Bs6ALX/9Bs6ALb/9Bs6ALf/9Bs6ALj/9Bs6ALn/9Bs6ALr/9Bs6ALv/9Bs6ALz/9Bs6AL3/9Bs6AL7/9Bs6AMH/9Bs6ANn/5ALqANr/7hrqAN//7gLkAOD/5ALqAOH/5ALqAOL/5ALqAOP/5ALqAOT/5ALqAOn/9Bs6AOr/9Bs6AOv/9Bs6AOz/9Bs6AO3/9Bs6AO7/9Bs6AO//9Bs6APD/9Bs6APH/9Bs6APL/9Bs6AP3/9Bs6AT4ADAAAAVX/9Bs6AAEAKYAAAAEAcIAAAAEAPoAAAAEAd4AAAMgAAf/cAAAAAv/cAAAAA//cAAAABP/cAAAABf/cAAAABv/cAAAAB//cAAAACP/cAAAACf/cAAAACv/cAAAAC//cAAAADP/cAAAADf/yAAAADv/gFEAAD//gFEAAEP/gFEAAEf/gFEAAEv/gFEAAE//yAAAAFP/yAAAAFf/yAAAAFv/yAAAAF//yAAAAGP/yAAAAGf/yAAAAGv/yAAAAG//yAAAAHP/yAAAAHf/yAAAAHv/yAAAAH//yAAAAIP/yAAAAIf/gFEAAIv/gFEAAI//gFEAAJP/gFEAAJf/yAAAAJ//yAAAAKf/yAAAAKv/yAAAAK//yAAAALP/yAAAALf/yAAAALv/yAAAAL//yAAAAMP/aDZwAMf/yAAAAMv/yAAAAM//yAAAANP/yAAAANf/yAAAANv/yAAAAN//yAAAAOP/yAAAAOf/yAAAAOv/yAAAAO//yAAAAPP/yAAAAPf/yAAAAPv/yAAAAP//gFEAAQP/gFEAAQf/gFEAAQv/gFEAAQ//gFEAARP/gFEAARf/gFEAARv/gFEAAR//gFEAASP/gFEAASf/yAAAASv/yAAAAS//gFEAATP/yAAAATf/yAAAATv/yAAAAT//yAAAAUP/aFDQAVv/CBMQAV//CBMQAWP/CBMQAWf/wAAAAWv/wAAAAW//wAAAAXP/wAAAAXf/wAAAAXv/wAAAAX//wAAAAYP/wAAAAYf/wAAAAYv/wAAAAY//SEqIAZP/eGKwAaf/OEpYAav++CiIAa/++CiIAbP++CiIAbf++CiIAbv++CiIAb//aCiIAc//CBMQAdP/CBMQAdf/CBMQAdv/gFEwAd//gFEwAeP/gFEwAef/gFEwAev/gFEwAe//gFEwAfP/gFEwAff/gFEwAfv/gFEwAf//gFEwAgP/gFEwAgf/gFEwAg//gFEwAhP/gFEwAhf/gFEwAhv/gFEwAh//gFEwAiP/gFEwAiv/gFEwAi//gFEwAjP/gFEwAjf/gFEwAjv/gFEwAj//gFEwAkP/gFEwAkf/gFEwAkv/gFEwAk//gFEwAlP/gFEwAlf/mBL4Alv/gFEwAl//gFEwAmP/gFEwAmf/gFEwAtf/gFEwAtv/gFEwAt//gFEwAuP/gFEwAuf/gFEwAuv/gFEwAu//gFEwAvP/gFEwAvf/gFEwAvv/gFEwAwf/gFEwAxv/kAAAAzP/mBL4Azf/mBL4Azv/mBL4Az//qBLgA0P/qBLgA0f/qBLgA0v/qBLgA0//qBLgA1P/qBLgA1f/qBLgA1v/qBLgA1//qBLgA2P/qBLgA2f/eEpwA2v/gBLIA3//OEpYA4P/eEpwA4f/eEpwA4v/eEpwA4//eEpwA5P/eEpwA5f/uAAAA6f/gFEwA6v/gFEwA6//gFEwA7P/gFEwA7f/gFEwA7v/gFEwA7//gFEwA8P/gFEwA8f/gFEwA8v/gFEwA/f/gFEwA/v/mBL4BAf/mBL4BAv/mBL4BA//mBL4BBP/mBL4BBf/mBL4BBv/qBLgBB//qBLgBCP/qBLgBPv+8FEABS//oAAABTf/oAAABUv/uAAABU//uAAABVf/gFEwBXf/yAAABmv/oAAABm//yAAAAAQBpgAAAAQBPgAAAAQA8gAAAAQCBgAAAQgANAAABlAATAAABlAAUAAABlAAVAAABlAAWAAABlAAXAAABlAAYAAABlAAZAAABlAAaAAABlAAbAAABlAAcAAABlAAdAAABlAAeAAABlAAfAAABlAAgAAABlAAlAAABlAAnAAABlAApAAABlAAqAAABlAArAAABlAAsAAABlAAtAAABlAAuAAABlAAvAAABlAAxAAABlAAyAAABlAAzAAABlAA0AAABlAA1AAABlAA2AAABlAA3AAABlAA4AAABlAA5AAABlAA6AAABlAA7AAABlAA8AAABlAA9AAABlAA+AAABlABJAAABlABKAAABlABMAAABlABNAAABlABOAAABlABPAAABlABW/8ANugBX/8ANugBY/8ANugBk/9oT4gBp/+wTbgBq/7gBjgBr/7gBjgBs/7gBjgBt/7gBjgBu/7gBjgBz/8ANugB0/8ANugB1/8ANugEv/+oAAAEw/+oAAAE8AA4PagFFAAwT4gFL/9oN0gFN/9oN0gFdAAABlAGa/9oN0gGbAAABlAABAHuAAAAAAASAAACLAAH/uANoAAL/uANoAAP/uANoAAT/uANoAAX/uANoAAb/uANoAAf/uANoAAj/uANoAAn/uANoAAr/uANoAAv/uANoAAz/uANoAA3/9gNiABP/9gNiABT/9gNiABX/9gNiABb/9gNiABf/9gNiABj/9gNiABn/9gNiABr/9gNiABv/9gNiABz/9gNiAB3/9gNiAB7/9gNiAB//9gNiACD/9gNiACX/9gNiACf/9gNiACn/9gNiACr/9gNiACv/9gNiACz/9gNiAC3/9gNiAC7/9gNiAC//9gNiADD/bgNcADH/9gNiADL/9gNiADP/9gNiADT/9gNiADX/9gNiADb/9gNiADf/9gNiADj/9gNiADn/9gNiADr/9gNiADv/9gNiADz/9gNiAD3/9gNiAD7/9gNiAEn/9gNiAEr/9gNiAEz/9gNiAE3/9gNiAE7/9gNiAE//9gNiAFb/4ANWAFf/4ANWAFj/4ANWAGP/9ANiAGn/2ANQAGr/2AcmAGv/2AcmAGz/2AcmAG3/2AcmAG7/2AcmAG//3Aw+AHP/4ANWAHT/4ANWAHX/4ANWAHb/3BGWAHf/3BGWAHj/3BGWAHn/3BGWAHr/3BGWAHv/3BGWAHz/3BGWAH3/3BGWAH7/3BGWAH//3BGWAID/3BGWAIH/3BGWAIP/3BGWAIT/3BGWAIX/3BGWAIb/3BGWAIf/3BGWAIj/3BGWAIr/3BGWAIv/3BGWAIz/3BGWAI3/3BGWAI7/3BGWAI//3BGWAJD/3BGWAJH/3BGWAJL/3BGWAJP/3BGWAJT/3BGWAJb/3BGWAJf/3BGWAJj/3BGWAJn/3BGWALX/3BGWALb/3BGWALf/3BGWALj/3BGWALn/3BGWALr/3BGWALv/3BGWALz/3BGWAL3/3BGWAL7/3BGWAMH/3BGWAMb/5BGWAOn/3BGWAOr/3BGWAOv/3BGWAOz/3BGWAO3/3BGWAO7/3BGWAO//3BGWAPD/3BGWAPH/3BGWAPL/3BGWAPP/3AAAAP3/3BGWAS3/7gAAAS//qANKATD/qANKATz/ugcOAT7/wANEAUsAEhHaAU0AEhHaAVX/3BGWAV3/9gNiAZoAEhHaAZv/9gNiAAEAmoAAAAEAKoAAAAEANIAAAAEAfIAAAAEAuYAAAAEAIYAAAAEARYAAAAwAMP+2A8QAUP/oDuAAY//QAFAAZP/aDtoAaf/SAEoAb//yAAAApQAYAAAA3//wDiIBPP/cDigBPgAIDmwBQ//0AAABR//0AAAAAQA5gAAAAQBqgAAAjAAB/+EDmAAC/+EDmAAD/+EDmAAE/+EDmAAF/+EDmAAG/+EDmAAH/+EDmAAI/+EDmAAJ/+EDmAAK/+EDmAAL/+EDmAAM/+EDmAAO/7IDkgAP/7IDkgAQ/7IDkgAR/7IDkgAS/7IDkgAh/7IDkgAi/7IDkgAj/7IDkgAk/7IDkgAw/+YDjAA//7IDkgBA/7IDkgBB/7IDkgBC/7IDkgBD/7IDkgBE/7IDkgBF/7IDkgBG/7IDkgBH/7IDkgBI/7IDkgBL/7IDkgBQ/+AAAABW/5QDhgBX/5QDhgBY/5QDhgBZ/+gAAABa/+gAAABb/+gAAABc/+gAAABd/+gAAABe/+gAAABf/+gAAABg/+gAAABh/+gAAABi/+gAAABj/64DgABk/7QDegBq/5IDdABr/5IDdABs/5IDdABt/5IDdABu/5IDdABz/5QDhgB0/5QDhgB1/5QDhgB2/+ADbgB3/+ADbgB4/+ADbgB5/+ADbgB6/+ADbgB7/+ADbgB8/+ADbgB9/+ADbgB+/+ADbgB//+ADbgCA/+ADbgCB/+ADbgCD/+ADbgCE/+ADbgCF/+ADbgCG/+ADbgCH/+ADbgCI/+ADbgCK/+ADbgCL/+ADbgCM/+ADbgCN/+ADbgCO/+ADbgCP/+ADbgCQ/+ADbgCR/+ADbgCS/+ADbgCT/+ADbgCU/+ADbgCV/8oDaACW/+ADbgCX/+ADbgCY/+ADbgCZ/+ADbgC1/+ADbgC2/+ADbgC3/+ADbgC4/+ADbgC5/+ADbgC6/+ADbgC7/+ADbgC8/+ADbgC9/+ADbgC+/+ADbgDB/+ADbgDM/8oDaADN/8oDaADO/8oDaADZ/9gIbgDa/94DYgDf/+cDXADg/9gIbgDh/9gIbgDi/9gIbgDj/9gIbgDk/9gIbgDp/+ADbgDq/+ADbgDr/+ADbgDs/+ADbgDt/+ADbgDu/+ADbgDv/+ADbgDw/+ADbgDx/+ADbgDy/+ADbgD9/+ADbgD+/8oDaAEB/8oDaAEC/8oDaAED/8oDaAEE/8oDaAEF/8oDaAEt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\";\n\n//# sourceURL=webpack:///./public/fonts/Outfit/Outfit-VariableFont_wght.ttf?");

/***/ }),

/***/ "./public/images/photos/review-profile-1.png":
/*!***************************************************!*\
  !*** ./public/images/photos/review-profile-1.png ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = \"data:image/png;base64,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\";\n\n//# sourceURL=webpack:///./public/images/photos/review-profile-1.png?");

/***/ }),

/***/ "./public/images/photos/review-profile-2.png":
/*!***************************************************!*\
  !*** ./public/images/photos/review-profile-2.png ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = \"data:image/png;base64,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\";\n\n//# sourceURL=webpack:///./public/images/photos/review-profile-2.png?");

/***/ }),

/***/ "./public/images/photos/review-profile-3.png":
/*!***************************************************!*\
  !*** ./public/images/photos/review-profile-3.png ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = \"data:image/png;base64,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\";\n\n//# sourceURL=webpack:///./public/images/photos/review-profile-3.png?");

/***/ }),

/***/ "./public/styles/checkout.css":
/*!************************************!*\
  !*** ./public/styles/checkout.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_checkout_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./checkout.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/checkout.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_checkout_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_checkout_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_checkout_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_checkout_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./public/styles/checkout.css?");

/***/ }),

/***/ "./public/styles/reviews.css":
/*!***********************************!*\
  !*** ./public/styles/reviews.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_reviews_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./reviews.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/reviews.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_reviews_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_reviews_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_reviews_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_reviews_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./public/styles/reviews.css?");

/***/ }),

/***/ "./public/styles/styles.css":
/*!**********************************!*\
  !*** ./public/styles/styles.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./public/styles/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack:///./public/styles/styles.css?");

/***/ }),

/***/ "./src/checkout.jsx":
/*!**************************!*\
  !*** ./src/checkout.jsx ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n/* harmony import */ var _components_header_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/header.jsx */ \"./src/components/header.jsx\");\n/* harmony import */ var _components_footer_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/footer.jsx */ \"./src/components/footer.jsx\");\n/* harmony import */ var _components_reviews_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/reviews.jsx */ \"./src/components/reviews.jsx\");\n/* harmony import */ var _public_styles_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/styles/styles.css */ \"./public/styles/styles.css\");\n/* harmony import */ var _public_styles_checkout_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../public/styles/checkout.css */ \"./public/styles/checkout.css\");\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\n\n\nfunction Feild(props) {\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    filled = _React$useState2[0],\n    setFilled = _React$useState2[1];\n  var input = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  function change() {\n    if (input.current.value !== \"\") {\n      setFilled(true);\n      return;\n    }\n    setFilled(false);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__input\",\n    name: props.name\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    type: props.password ? \"password\" : \"text\",\n    ref: input,\n    name: props.name,\n    onChange: change,\n    placeholder: props.placeholder,\n    minlength: props.minlength,\n    required: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-circle-check\",\n    style: {\n      color: filled ? \"var(--green-1)\" : \"black\",\n      opacity: filled ? \"1\" : \"0.4\"\n    }\n  }));\n}\nfunction App() {\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    submitted = _React$useState4[0],\n    setSubmitted = _React$useState4[1];\n  var form = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  function submit(e) {\n    e.preventDefault();\n    setSubmitted(null);\n    var _form$current$element = form.current.elements,\n      firstname = _form$current$element.firstname,\n      lastname = _form$current$element.lastname,\n      email = _form$current$element.email,\n      password = _form$current$element.password,\n      password_re = _form$current$element.password_re,\n      tos = _form$current$element.tos;\n    fetch(\"/register\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        firstname: firstname.value,\n        lastname: lastname.value,\n        email: email.value,\n        password: password.value,\n        passwordre: password_re.value,\n        tos: tos.value\n      })\n    }).then(function (data) {\n      setSubmitted(true);\n    });\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"main-container\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_header_jsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"main\", {\n    className: \"register\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__success\",\n    style: {\n      display: submitted ? \"block\" : \"none\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-circle-check\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n    className: \"register__success-heading\"\n  }, \"Success!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", {\n    className: \"register__success-message\"\n  }, \"You'll receive an email link shortly for you to fill out your applicant profile.\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"form\", {\n    ref: form,\n    onSubmit: submit,\n    className: \"register__form\",\n    method: \"POST\",\n    action: \"/register\",\n    style: {\n      display: submitted ? \"none\" : \"block\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h1\", {\n    className: \"register__heading\"\n  }, \"Welcome back!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    name: \"email\",\n    placeholder: \"Email\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Feild, {\n    password: true,\n    minlength: 8,\n    name: \"password\",\n    placeholder: \"Password\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"register__password-details\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/register\",\n    className: \"login__register-link\"\n  }, \"I don't have an account yet!\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    type: \"submit\",\n    style: {\n      opacity: submitted === null ? \"0.5\" : \"1\"\n    }\n  }, \"Submit\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components_footer_jsx__WEBPACK_IMPORTED_MODULE_3__[\"default\"], null)));\n}\nvar root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(document.getElementById(\"root\"));\nroot.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, null));\n\n//# sourceURL=webpack:///./src/checkout.jsx?");

/***/ }),

/***/ "./src/components/footer.jsx":
/*!***********************************!*\
  !*** ./src/components/footer.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Footer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer(props) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"footer\", {\n    className: \"footer\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__content\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__title\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"footer__logo\",\n    src: \"/public/images/icons/centro-website-logo.png\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"JOB SERVICES\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Pages\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/pricing\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/login\"\n  }, \"Login\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/register\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/account\"\n  }, \"My Account\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Our Services\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Virtual Job Application\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Resume and Cover Letter Optimization\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Job Application Tailoring\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"Referral Generation\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"More\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/terms-of-service\"\n  }, \"Terms of Service\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/privacy-policy\"\n  }, \"Privacy Policy\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"/cookie-policy\"\n  }, \"Cookie Policy\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__menu\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Contact\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"admin@crcentro.com\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    href: \"\"\n  }, \"(+506) 7063-8994\")))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"footer__copyright\"\n  }, \"\\xA9 2025 Copyright Centro, All rights reserved.\"));\n}\n\n//# sourceURL=webpack:///./src/components/footer.jsx?");

/***/ }),

/***/ "./src/components/header.jsx":
/*!***********************************!*\
  !*** ./src/components/header.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Header)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nfunction Header() {\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    menuOpen = _React$useState2[0],\n    setMenuOpen = _React$useState2[1];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"header\", {\n    className: \"header\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"header__logo\",\n    src: \"/public/images/icons/centro-website-logo.png\",\n    onClick: function onClick() {\n      return window.location = \"/\";\n    }\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h2\", {\n    className: \"header__subtitle\"\n  }, \"JOB SERVICES\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", {\n    className: \"header__nav\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/pricing\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/register\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"nav__link\",\n    href: \"/login\"\n  }, \"My Account\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"header__dropdown\",\n    onClick: function onClick() {\n      return setMenuOpen(!menuOpen);\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"dropdown__dot\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"nav\", {\n    className: \"header__submenu\",\n    style: {\n      display: menuOpen ? \"block\" : \"none\"\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/\"\n  }, \"Home\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/pricing\"\n  }, \"Pricing\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/register\"\n  }, \"Register\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/login\"\n  }, \"Login\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", {\n    className: \"header__sublink\",\n    href: \"/login\"\n  }, \"My Account\")))));\n}\n\n//# sourceURL=webpack:///./src/components/header.jsx?");

/***/ }),

/***/ "./src/components/reviews.jsx":
/*!************************************!*\
  !*** ./src/components/reviews.jsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Reviews)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _public_styles_styles_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../public/styles/styles.css */ \"./public/styles/styles.css\");\n/* harmony import */ var _public_styles_reviews_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../public/styles/reviews.css */ \"./public/styles/reviews.css\");\n/* harmony import */ var _public_images_photos_review_profile_1_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../public/images/photos/review-profile-1.png */ \"./public/images/photos/review-profile-1.png\");\n/* harmony import */ var _public_images_photos_review_profile_2_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../public/images/photos/review-profile-2.png */ \"./public/images/photos/review-profile-2.png\");\n/* harmony import */ var _public_images_photos_review_profile_3_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../public/images/photos/review-profile-3.png */ \"./public/images/photos/review-profile-3.png\");\n\n\n\n\n\n\nfunction Reviews() {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"section\", {\n    className: \"reviews\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h2\", {\n    className: \"reviews__heading\"\n  }, \"A few words from Our Satisfied Clients!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n    className: \"review__name\"\n  }, \"Stephanie Davies\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"review__profile\",\n    src: _public_images_photos_review_profile_1_png__WEBPACK_IMPORTED_MODULE_3__\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"q\", {\n    className: \"review__quote\"\n  }, \"Centro was a huge help, landed my first full-time job in my feild after I graduated, couldn't be happier!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review__stars\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"- 3\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n    className: \"review__name\"\n  }, \"Dante Willis\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"review__profile\",\n    src: _public_images_photos_review_profile_2_png__WEBPACK_IMPORTED_MODULE_4__\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"q\", {\n    className: \"review__quote\"\n  }, \"Centro helped me finally get the position I was hoping for after months of job-searching. Definitely a life-saver.\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review__stars\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"- 3\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n    className: \"review__name\"\n  }, \"David Ibarra\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", {\n    className: \"review__profile\",\n    src: _public_images_photos_review_profile_3_png__WEBPACK_IMPORTED_MODULE_5__\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"q\", {\n    className: \"review__quote\"\n  }, \"Managed to get referred after a friend recommended I give Centro a try so it was worth the investment!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"review__stars\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"i\", {\n    className: \"fa-solid fa-star\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"- 2.8\"))));\n}\n\n//# sourceURL=webpack:///./src/components/reviews.jsx?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"checkout": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/checkout.jsx");
/******/ 	
/******/ })()
;